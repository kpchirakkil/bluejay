diff --git a/Photochemistry/src/Core.jl b/Photochemistry/src/Core.jl
index 5128abd..3f1edc5 100644
--- a/Photochemistry/src/Core.jl
+++ b/Photochemistry/src/Core.jl
@@ -88,60 +88,103 @@ function electron_density(atmdict; globvars...)
     required = [:e_profile_type, :ion_species, :non_bdy_layers]
     check_requirements(keys(GV), required)
 
-    if GV.e_profile_type=="constant"
-        E = [1e5 for i in GV.non_bdy_layers]
-    elseif GV.e_profile_type=="quasineutral"
-        E = sum([atmdict[sp] for sp in GV.ion_species])
-    elseif GV.e_profile_type=="none"  # For neutrals-only simulation but without changing how E is passed to other functions. 
-        E = [0. for i in GV.non_bdy_layers]
+    # Determine how many horizontal columns are present.
+    n_horiz = get(GV, :n_horiz, 1)
+
+    if GV.e_profile_type == "constant"
+        # Fill with a constant electron density profile for every column.
+        template = fill(1e5, length(GV.non_bdy_layers))
+        return [copy(template) for _ in 1:n_horiz]
+
+    elseif GV.e_profile_type == "quasineutral"
+        # Multi column atmospheres store species as vectors of altitude arrays.
+        # Handle both the legacy single column format and the new multicolumn
+        # format.
+        if atmdict[GV.ion_species[1]] isa Vector
+            return [sum(atmdict[sp][ih] for sp in GV.ion_species)
+                    for ih in 1:n_horiz]
+        else
+            return [sum(atmdict[sp] for sp in GV.ion_species)]
+        end
+
+    elseif GV.e_profile_type == "none"
+        template = zeros(length(GV.non_bdy_layers))
+        return [copy(template) for _ in 1:n_horiz]
+
     else
-        throw("Unhandled electron profile specification: $(e_profile_type)")
+        throw("Unhandled electron profile specification: $(GV.e_profile_type)")
     end
-    return E
 end
 
-function find_exobase(sp::Symbol, atmdict::Dict{Symbol, Vector{ftype_ncur}}; returntype="index", verbose=false, globvars...)
+function find_exobase(sp::Symbol, atmdict::Dict{Symbol, Vector{Array{ftype_ncur}}};
+                      returntype="index", verbose=false, globvars...)
     #=
     Finds the exobase altitude, where mean free path is equal to a scale height.
     ONLY VALID FOR H AND D (because collision_xsect only includes xsects for those, and they're H and D on O)
 
     Inputs:
-        s: species 
+        sp: species 
         atmdict: Atmospheric state dictionary
         returntype: whether to return the "altitude" in km or the "index" in the n_alt_index dictionary. 
     Output:
-        Altitude of exobase in cm
+        Array of exobase altitudes or indices for each horizontal column.
     =#
 
-    if (sp != :H) || (sp != :D)
-        throw("find_exobase is not defined for species other than H and D at this time.")
+    if !(sp in [:H, :D])
+        throw("find_exobase is only defined for species H and D at this time.")
     end
 
     GV = values(globvars)
-    required =  [:all_species, :alt, :collision_xsect, :M_P, :molmass, :non_bdy_layers, :n_alt_index, :R_P, :Tn, :zmax]
+    required = [:all_species, :alt, :collision_xsect, :M_P, :molmass, :non_bdy_layers, 
+                :n_alt_index, :R_P, :Tn, :zmax, :n_horiz]
     check_requirements(keys(GV), required)
 
-    H_s = scaleH(GV.non_bdy_layers, sp, GV.Tn[2:end-1]; globvars...)
-    mfp_sp = 1 ./ (GV.collision_xsect[sp] .* n_tot(atmdict; GV.all_species, GV.n_alt_index))
-    exobase_alt = findfirst(mfp_sp .>= H_s)
+    exobase_altitudes = fill(NaN, GV.n_horiz)
+    exobase_indices = fill(0, GV.n_horiz)
+
+    # Loop over each horizontal column to find individual exobase altitudes
+    for ihoriz in 1:GV.n_horiz
+        Tn_col = GV.Tn[ihoriz, :]
 
-    if typeof(exobase_alt)==Nothing # If no exobase is found, use the top of the atmosphere.
-        if verbose
-            println("Warning: No exobase found for species $(sp); assuming top of atmosphere, but this is not guaranteed to be true.")
+        # Calculate scale height using temperature for this column
+        # H_s = scaleH(GV.non_bdy_layers, sp, Tn_col[ihoriz, 2:end-1]; globvars...)
+        H_s = scaleH(GV.non_bdy_layers, sp, Tn_col[2:end-1]; globvars...)
+
+        # Mean free path calculation for each vertical column separately
+        mfp_sp = 1 ./ (GV.collision_xsect[sp] .* n_tot(atmdict, ihoriz; GV.all_species, GV.n_alt_index))
+
+        exobase_alt = findfirst(mfp_sp .>= H_s)
+
+        if exobase_alt === nothing # If no exobase is found, use the top of the atmosphere.
+            if verbose
+                println("Warning: No exobase found for species $(sp) at column $(ihoriz); assuming top of atmosphere, but this is not guaranteed to be true.")
+            end
+            exobase_altitudes[ihoriz] = GV.zmax
+            exobase_indices[ihoriz] = GV.n_alt_index[GV.zmax]
+        else
+            exobase_altitudes[ihoriz] = GV.alt[exobase_alt]
+            exobase_indices[ihoriz] = exobase_alt
         end
-        returnme = Dict("altitude"=>GV.zmax, "index"=>GV.n_alt_index[GV.zmax])
+    end
+
+    # Choose the return type: altitude or index
+    if returntype=="altitude"
+        return exobase_altitudes
+    elseif returntype=="index"
+        return exobase_indices
     else
-        returnme = Dict("altitude"=>GV.alt[exobase_alt], "index"=>exobase_alt)
+        throw("Invalid returntype specified. Choose 'altitude' or 'index'")
     end
-    return returnme[returntype]
 end
 
-function meanmass(atmdict::Dict{Symbol, Vector{ftype_ncur}}; ignore=[], globvars...)
+function meanmass(atmdict::Dict{Symbol, Vector{Array{ftype_ncur}}}, n_horiz::Int64, ihoriz::Int64; ignore=[], globvars...)
     #= 
     Override for vector form. Calculates mean molecular mass at all atmospheric layers.
 
     Inputs:
         atmdict: Array; species number density by altitude
+        n_horiz: Integer; number of vertical columns in the model
+        ihoriz: Integer; vertical column index
         ignore: Set; contains symbols representing species to ignore in the calculation
 
     Outputs:
@@ -152,7 +195,8 @@ function meanmass(atmdict::Dict{Symbol, Vector{ftype_ncur}}; ignore=[], globvars
     required = [:all_species, :molmass, :n_alt_index]
     check_requirements(keys(GV), required)
 
-    counted_species = setdiff(GV.all_species, ignore)
+    # counted_species = setdiff(GV.all_species, ignore)
+    counted_species = [s for s in GV.all_species if haskey(atmdict, s) && !(s in ignore)]
 
     # Delete ignored species from the dictionary since we have to transform it
     trimmed_atmdict = deepcopy(atmdict)
@@ -160,21 +204,24 @@ function meanmass(atmdict::Dict{Symbol, Vector{ftype_ncur}}; ignore=[], globvars
         delete!(trimmed_atmdict, isp)
     end
 
-    # Gets the atmosphere as a matrix with rows = altitudes and cols = species
-    # so we can do matrix multiplication.
-    n_mat = transpose(atm_dict_to_matrix(trimmed_atmdict, counted_species))
+    # Gets the atmosphere as a matrix with rows = altitudes, cols = species, and the third dimension as vertical columns
+    # so we can do matrix multiplication. Only counted species are included so
+    # that ignored species do not contribute to the mean.
+    n_mat = permutedims(atm_dict_to_matrix(trimmed_atmdict, counted_species, n_horiz), (2, 1, 3))
 
     m = [GV.molmass[sp] for sp in counted_species] # this will always be 1D
 
     weighted_mm = zeros(size(n_mat)[1]) # This will store the result
 
-    # Multiply densities of each species by appropriate molecular mass 
-    mul!(weighted_mm, n_mat, m)
+    # Multiply the density of each species in the requested column by its
+    # molecular mass.  The third dimension of `n_mat` corresponds to the
+    # horizontal column number.
+    mul!(weighted_mm, n_mat[:, :, ihoriz], m)
 
-    return weighted_mm ./ n_tot(trimmed_atmdict; all_species=counted_species, GV.n_alt_index)
+    return weighted_mm ./ n_tot(trimmed_atmdict, ihoriz; all_species=counted_species, GV.n_alt_index)
 end
 
-function n_tot(atmdict::Dict{Symbol, Vector{ftype_ncur}}, z; ignore=[], globvars...)
+function n_tot(atmdict::Dict{Symbol, Vector{Array{ftype_ncur}}}, z, ihoriz::Int64; ignore=[], globvars...)
     #= 
     Calculates total atmospheric density at altitude z.
 
@@ -182,6 +229,7 @@ function n_tot(atmdict::Dict{Symbol, Vector{ftype_ncur}}, z; ignore=[], globvars
         atmdict: dictionary of atmospheric density profiles by altitude
         z: altitude, in cm
         ignore: Set; contains symbols representing species to ignore in the calculation
+        ihoriz: vertical column index
     Output: 
         Density of the atmosphere at altitude z
     =#
@@ -189,19 +237,23 @@ function n_tot(atmdict::Dict{Symbol, Vector{ftype_ncur}}, z; ignore=[], globvars
     required = [:n_alt_index, :all_species]
     check_requirements(keys(GV), required)
 
-    counted_species = setdiff(GV.all_species, ignore)
+    # counted_species = setdiff(GV.all_species, ignore)
+    counted_species = [s for s in GV.all_species if haskey(atmdict, s) && !(s in ignore)]
 
     thisaltindex = GV.n_alt_index[z]
-    return sum( [atmdict[s][thisaltindex] for s in counted_species] )
+    # Sum the densities of all counted species at the specified altitude and
+    # horizontal column.
+    return sum(atmdict[s][ihoriz][thisaltindex] for s in counted_species)
 end
 
-function n_tot(atmdict::Dict{Symbol, Vector{ftype_ncur}}; ignore=[], globvars...)
+function n_tot(atmdict::Dict{Symbol, Vector{Array{ftype_ncur}}}, ihoriz::Int64; ignore=[], globvars...)
     #= 
     Override to calculate total atmospheric density at all altitudes.
 
     Input: 
         atmdict: dictionary of atmospheric density profiles by altitude
         ignore: Set; contains symbols representing species to ignore in the calculation
+        ihoriz: vertical column index
     Output: 
         Density of the atmosphere at all non-boundary layer altitudes.
 
@@ -210,62 +262,73 @@ function n_tot(atmdict::Dict{Symbol, Vector{ftype_ncur}}; ignore=[], globvars...
     GV = values(globvars)
     required =  [:all_species]
     check_requirements(keys(GV), required)
-
-    counted_species = setdiff(GV.all_species, ignore)
-    ndensities = zeros(length(counted_species), length(atmdict[collect(keys(atmdict))[1]]))
+    
+    # counted_species = setdiff(GV.all_species, ignore)
+    counted_species = [s for s in GV.all_species if haskey(atmdict, s) && !(s in ignore)]
+    # allocate an array to gather density profiles for this vertical column
+    if isempty(counted_species)
+        return zeros(length(atmdict[collect(keys(atmdict))[1]][ihoriz]))
+    end
+    ndensities = zeros(length(counted_species), length(atmdict[collect(keys(atmdict))[1]][ihoriz]))
 
     for i in 1:length(counted_species)
-        ndensities[i, :] = atmdict[counted_species[i]]
+        # copy the density profile for each species at this column
+        ndensities[i, :] = atmdict[counted_species[i]][ihoriz]
     end
 
     # returns the sum over all species at each altitude as a vector.
-    return vec(sum(ndensities, dims=1)) 
+    return vec(sum(ndensities, dims=1))
 end
 
-function optical_depth(n_cur_densities; globvars...)
+function optical_depth(n_cur_densities; n_horiz::Int64, globvars...)
     #=
-    Given the current state (atmdict), this populates solarabs, a 1D array of 1D arrays 
-    (which is annoying, but required for using BLAS.axpy! for some inscrutable reason) 
-    with the optical depth of the atmosphere. The shape of solar abs is 124 elements, each 
-    its own array of 2000 elements. 
+    Given the current state (atmdict), this populates solarabs, a 2D array structured as [n_horiz, num_layers],
+    with each element containing an array of 2000 elements (one per wavelength).
+
+    The optical depth is calculated independently for each horizontal column.
     =#
-    
+
     GV = values(globvars)
     required = [:num_layers, :Jratelist, :absorber, :crosssection, :dz]
     check_requirements(keys(GV), required)
-    
+
     nlambda = 2000
-    
-    # Initialize the solar absorption array with 0s for all wavelengths.
-    solarabs = Array{Array{Float64}}(undef, GV.num_layers)
-    for i in range(1, length=GV.num_layers)
-        solarabs[i] = zeros(Float64, nlambda)
-    end
-    
+
+    # Initialize the solar absorption array for all wavelengths and horizontal columns.
+    solarabs = [[zeros(Float64, nlambda) for ialt in 1:GV.num_layers] for ihoriz in 1:n_horiz]
+
     for jspecies in GV.Jratelist
         species = GV.absorber[jspecies]
 
-        jcolumn = convert(Float64, 0.)
-
-        for ialt in [GV.num_layers:-1:1;]
-            #get the (overhead) vertical column of the absorbing constituent
-            jcolumn += convert(Float64, n_cur_densities[species][ialt])*GV.dz
-
-           
-            # add the total extinction to solarabs:
-            # multiplies air column density (N, #/cm^2) at all wavelengths by crosssection (σ)
-            # to get optical depth (τ). This is an override of axpy! to use the
-            # full arguments. For the equation Y' = alpha*X + Y:
-            # ARG 1: n (length of arrays in ARGS 3, 5)
-            # ARG 2: alpha, a scalar.
-            # ARG 3: X, an array of length n.
-            # ARG 4: the increment of the index values of X, maybe?
-            # ARG 5: Y, an array of length n
-            # ARG 6: increment of index values of Y, maybe?
-            
-            BLAS.axpy!(nlambda, jcolumn, GV.crosssection[jspecies][ialt+1], 1, solarabs[ialt], 1)
+        # Skip species absent from either the current atmosphere or the cross-section dictionary
+        if !(haskey(n_cur_densities, species) && haskey(GV.crosssection, jspecies))
+            continue
+        end
+
+        for ihoriz in 1:n_horiz
+            jcolumn = convert(Float64, 0.)
+
+            for ialt in GV.num_layers:-1:1
+                # Vertical column of the absorbing constituent for this horizontal column
+                jcolumn += convert(Float64, n_cur_densities[species][ihoriz][ialt]) * GV.dz
+
+                # Add total extinction to solarabs for this horizontal column and altitude
+                # multiplies air column density (N, #/cm^2) at all wavelengths by crosssection (σ)
+                # to get optical depth (τ). This is an override of axpy! to use the
+                # full arguments. For the equation Y' = alpha*X + Y:
+                # ARG 1: n (length of arrays in ARGS 3, 5)
+                # ARG 2: alpha, a scalar.
+                # ARG 3: X, an array of length n.
+                # ARG 4: the increment of the index values of X, maybe?
+                # ARG 5: Y, an array of length n
+                # ARG 6: increment of index values of Y, maybe?
+
+                # updated optical_depth to read column-specific cross sections when computing extinction
+                BLAS.axpy!(nlambda, jcolumn, GV.crosssection[jspecies][ihoriz][ialt+1], 1, solarabs[ihoriz][ialt], 1)
+            end
         end
     end
+
     return solarabs
 end
 
@@ -304,11 +367,13 @@ function scaleH(z, sp::Symbol, T; globvars...)
     return @. kB*T/(GV.molmass[sp]*mH*GV.M_P*bigG)*(((z+GV.R_P))^2)
 end
 
-function scaleH(atmdict::Dict{Symbol, Vector{ftype_ncur}}, T::Vector; ignore=[], globvars...)
+function scaleH(atmdict::Dict{Symbol, Vector{Array{ftype_ncur}}}, T::Vector, n_horiz::Int64, ihoriz::Int64; ignore=[], globvars...)
     #= 
     Input:
         atmdict: Present atmospheric state dictionary
         T: temperature array for the neutral atmosphere
+        n_horiz: number of vertical columns in the model
+        ihoriz: vertical column index
         ignore: Set; contains symbols representing species to ignore in the calculation
     Output:
         Mean atmospheric scale height at all altitudes (in cm)
@@ -320,7 +385,7 @@ function scaleH(atmdict::Dict{Symbol, Vector{ftype_ncur}}, T::Vector; ignore=[],
 
     counted_species = setdiff(GV.all_species, ignore)
 
-    mm_vec = meanmass(atmdict; ignore=ignore, globvars...)
+    mm_vec = meanmass(atmdict, n_horiz, ihoriz; ignore=ignore, globvars...)
     return @. kB*T/(mm_vec*mH*GV.M_P*bigG)*(((GV.alt+GV.R_P))^2)
 end
 
@@ -349,36 +414,39 @@ end
 # Subsection - functions that manipulate the atmospheric dictionary/matrix object.
 #---------------------------------------------------------------------------------#
 
-function atm_dict_to_matrix(atmdict::Dict{Symbol, Vector{ftype_ncur}}, species_list)
+function atm_dict_to_matrix(atmdict::Dict{Symbol, Vector{Array{ftype_ncur}}}, species_list, n_horiz::Int64)
     #=
     Converts atmospheric state dictionary atmdict to a matrix,
     such that rows correspond to species in the order listed in species_list
-    and columns correspond to altitudes in the order lowest-->highest.
+    and columns correspond to altitudes in the order lowest-->highest
+    and the third dimension corresponds to the vertical column in the order lowest-->highest.
     =#
     
-    num_alts = length(atmdict[collect(keys(atmdict))[1]])
-    n_mat = zeros(length(species_list), num_alts)
+    num_alts = length(atmdict[collect(keys(atmdict))[1]][1])
+    n_mat = zeros(length(species_list), num_alts, n_horiz)
     
     for i in 1:length(species_list)
-        n_mat[i, :] = atmdict[species_list[i]]
+        for ihoriz in 1:n_horiz
+            n_mat[i, :, ihoriz] = atmdict[species_list[i]][ihoriz]
+	end
     end
     
     return n_mat
 end
 
-function atm_matrix_to_dict(n_matrix, species_list)
+function atm_matrix_to_dict(n_matrix, species_list, n_horiz::Int64)
     #=
     Input:
         n_matrix: matrix of the atmospheric state
     Output:
         dictionary for only the species in species_list
     =#
-    atmdict = Dict{Symbol, Vector{ftype_ncur}}([species_list[k]=>n_matrix[k, :] for k in 1:length(species_list)])
+    atmdict = Dict{Symbol, Vector{Array{ftype_ncur}}}([species_list[k]=>[n_matrix[k, :, ihoriz] for ihoriz in 1:n_horiz] for k in 1:length(species_list)])
     
     return atmdict
 end
 
-function compile_ncur_all(n_long, n_short, n_inactive; globvars...)
+function compile_ncur_all(n_long, n_horiz::Int64, n_short, n_inactive; globvars...)
     #=
     While the simulation runs, "n", the vector passed to the solver, only contains densities
     for long-lived, active species. Every time the atmospheric state changes, the transport coefficients
@@ -398,9 +466,9 @@ function compile_ncur_all(n_long, n_short, n_inactive; globvars...)
     required = [:active_longlived, :active_shortlived, :inactive_species, :num_layers]
     check_requirements(keys(GV), required)
 
-    n_cur_active_long = unflatten_atm(n_long, GV.active_longlived; num_layers=GV.num_layers)
-    n_cur_active_short = unflatten_atm(n_short, GV.active_shortlived; num_layers=GV.num_layers)
-    n_cur_inactive = unflatten_atm(n_inactive, GV.inactive_species; num_layers=GV.num_layers)
+    n_cur_active_long = unflatten_atm(n_long, GV.active_longlived, n_horiz; num_layers=GV.num_layers)
+    n_cur_active_short = unflatten_atm(n_short, GV.active_shortlived, n_horiz; num_layers=GV.num_layers)
+    n_cur_inactive = unflatten_atm(n_inactive, GV.inactive_species, n_horiz; num_layers=GV.num_layers)
 
     n_cur_all = Dict(vcat([k=>n_cur_active_long[k] for k in keys(n_cur_active_long)],
                           [k=>n_cur_active_short[k] for k in keys(n_cur_active_short)],
@@ -409,13 +477,13 @@ function compile_ncur_all(n_long, n_short, n_inactive; globvars...)
     return n_cur_all
 end
 
-function flatten_atm(atmdict::Dict{Symbol, Vector{ftype_ncur}}, species_list; globvars...) 
+function flatten_atm(atmdict::Dict{Symbol, Vector{Array{ftype_ncur}}}, species_list, n_horiz::Int64; globvars...) 
     #=
     Input:
         atmdict: atmospheric densities by altitude
         species_list: Included species which will have profiles flattened
     Output:
-        Vector of form [n_sp1(z=0), n_sp2(z=0)...n_sp1(z=zmax)...n_spN(z=zmax)]
+        Vector of form [n_sp1(h=1,z=0), n_sp2(h=1,z=0)...n_sp1(h=1,z=zmax)...n_spN(h=1,z=zmax),n_sp1(h=2,z=0), n_sp2(h=2,z=0)...n_sp1(h=2,z=zmax)...n_spN(h=2,z=zmax)]
     
     This function is the reverse of unflatten_atm. 
     =#
@@ -424,10 +492,13 @@ function flatten_atm(atmdict::Dict{Symbol, Vector{ftype_ncur}}, species_list; gl
     required =  [:num_layers]
     check_requirements(keys(GV), required)
 
-    return deepcopy(ftype_ncur[[atmdict[sp][ialt] for sp in species_list, ialt in 1:GV.num_layers]...])
+    # Construct a matrix in the (species, altitude, column) layout and then
+    # flatten it with Julia's column-major ordering so that unflatten_atm can
+    # correctly reshape it.
+    return vec(atm_dict_to_matrix(atmdict, species_list, n_horiz))
 end
 
-function ncur_with_boundary_layers(atmdict_no_bdys::Dict{Symbol, Vector{ftype_ncur}}; globvars...)
+function ncur_with_boundary_layers(atmdict_no_bdys::Dict{Symbol, Vector{Array{ftype_ncur}}}, n_horiz::Int64; globvars...)
     #=
     Here's a weird one. The atmospheric density matrix stores values for each
     species (column of the matrix) at each altitude (row of the matrix) of the atmosphere. 
@@ -455,19 +526,20 @@ function ncur_with_boundary_layers(atmdict_no_bdys::Dict{Symbol, Vector{ftype_nc
     # This gets a sorted list of the clamped indices, so it's [1, 1, 2, 3...end-1, end, end].
     clamped_n_alt_index = sort(collect(values(GV.n_alt_index)))
     
-    atmdict_with_bdy_layers = Dict{Symbol, Vector{ftype_ncur}}()
+    atmdict_with_bdy_layers = Dict{Symbol, Vector{Array{ftype_ncur}}}()
     
     # Fill the dictionary with the profile. This duplicates the lowest and highest altitude values.
     for i in 1:length(GV.all_species)
-        atmdict_with_bdy_layers[GV.all_species[i]] = atmdict_no_bdys[GV.all_species[i]][clamped_n_alt_index]
+        atmdict_with_bdy_layers[GV.all_species[i]] = ([atmdict_no_bdys[GV.all_species[i]][ihoriz][clamped_n_alt_index] for ihoriz in 1:n_horiz])
     end
     return atmdict_with_bdy_layers
 end
 
-function unflatten_atm(n_vec, species_list; globvars...)
+function unflatten_atm(n_vec, species_list, n_horiz::Int64; globvars...)
     #=
     Input:
-        n_vec: flattened density vector for the species in species_list: [n_sp1(z=0), n_sp2(z=0)...n_sp1(z=250)...n_spN(z=250)] 
+        n_vec: flattened density vector for the species in species_list: [n_sp1(h=1,z=0), n_sp2(h=1,z=0)...n_sp1(h=1,z=zmax)...n_spN(h=1,z=zmax),n_sp1(h=2,z=0), n_sp2(h=2,z=0)...n_sp1(h=2,z=zmax)...n_spN(h=2,z=zmax)]
+
     Output:
         dictionary of atmospheric densities by altitude with species as keys 
 
@@ -477,9 +549,9 @@ function unflatten_atm(n_vec, species_list; globvars...)
     required =  [:num_layers]
     check_requirements(keys(GV), required)
 
-    n_matrix = reshape(n_vec, (length(species_list), GV.num_layers))
+    n_matrix = reshape(n_vec, (length(species_list), GV.num_layers, n_horiz))
 
-    return atm_matrix_to_dict(n_matrix, species_list)
+    return atm_matrix_to_dict(n_matrix, species_list, n_horiz)
 end
 
 #===============================================================================#
@@ -573,7 +645,7 @@ function check_jacobian_eigenvalues(J, path)
     end
 end
 
-function chemical_jacobian(specieslist, dspecieslist; diff_wrt_e=true, diff_wrt_m=true, globvars...)
+function chemical_jacobian(specieslist, dspecieslist; diff_wrt_e=true, diff_wrt_m=true, transportnet_horiz, globvars...)
     #= 
     Compute the symbolic chemical jacobian of a supplied chemnet and transportnet
     for the specified specieslist. 
@@ -605,6 +677,7 @@ function chemical_jacobian(specieslist, dspecieslist; diff_wrt_e=true, diff_wrt_
 
     nspecies = length(specieslist)  # this is the active species. 
     ndspecies = length(dspecieslist)  # this is the species with respect to which we differentiate
+
     if diff_wrt_e==true
         required = [:ion_species]
         check_requirements(keys(GV), required)
@@ -625,7 +698,9 @@ function chemical_jacobian(specieslist, dspecieslist; diff_wrt_e=true, diff_wrt_
         if issubset([ispecies],GV.transport_species)
             peqn = [peqn; production_equations(ispecies, GV.transportnet)]
             leqn = [leqn; loss_equations(ispecies, GV.transportnet)]
-        end
+	    peqn = [peqn; production_equations(ispecies, transportnet_horiz)]
+	    leqn = [leqn; loss_equations(ispecies, transportnet_horiz)]
+	end
 
         # Account for e's
         if diff_wrt_e
@@ -698,13 +773,20 @@ function chemical_jacobian(specieslist, dspecieslist; diff_wrt_e=true, diff_wrt_
     return (ivec, jvec, tvec)
 end
 
-function eval_rate_coef(atmdict::Dict{Symbol, Vector{ftype_ncur}}, krate::Expr; globvars...)
+# function eval_rate_coef(atmdict::Dict{Symbol, Vector{Array{ftype_ncur}}}, krate::Expr, ihoriz::Int64; globvars...)
+function eval_rate_coef(
+    atmdict::Dict{Symbol, Vector{Array{ftype_ncur}}},
+    krate::Expr,
+    ihoriz::Int64;
+    globvars...
+)
     #=
     Evaluates a chemical reaction rate coefficient, krate, for all levels of the atmosphere. 
 
     Input:
         atmdict: the atmospheric state dictionary
         krate: rate coefficient for a single reaction
+	ihoriz: Vertical column index
         tn, _i, _e: temperature profiles for neutrals, ions, electrons
     Output:
         rate_coefficient: evaluated rate coefficient at all atmospheric layers
@@ -716,10 +798,35 @@ function eval_rate_coef(atmdict::Dict{Symbol, Vector{ftype_ncur}}, krate::Expr;
     # Set stuff up
     eval_k = mk_function(:((Tn, Ti, Te, M) -> $krate))
 
-    return eval_k(GV.Tn, GV.Ti, GV.Te, sum([atmdict[sp] for sp in GV.all_species])) 
+    # Grab the temperature profiles for this column and drop the boundary layers
+    Tn_data = GV.Tn
+    Ti_data = GV.Ti
+    Te_data = GV.Te
+
+    # When get_volume_rates is called for a single column, Tn, Ti and Te may
+    # already be 1-D vectors. Support both cases gracefully.
+    if ndims(Tn_data) == 2
+        Tn_col = Tn_data[ihoriz, 2:end-1]
+        Ti_col = Ti_data[ihoriz, 2:end-1]
+        Te_col = Te_data[ihoriz, 2:end-1]
+    else
+        # The arrays already exclude boundary layers
+        Tn_col = Tn_data
+        Ti_col = Ti_data
+        Te_col = Te_data
+    end
+
+    return eval_k(
+        Tn_col,
+        Ti_col,
+        Te_col,
+        sum([atmdict[sp][ihoriz] for sp in GV.all_species]),
+    )
 end 
 
-function getrate(sp::Symbol; chemistry_on=true, transport_on=true, sepvecs=false, globvars...)
+# function getrate(sp::Symbol; chemistry_on=true, transport_on=true, sepvecs=false, globvars...)
+function getrate(sp::Symbol; chemistry_on=true, transport_on=true, sepvecs=false,
+                  transportnet_horiz=[], globvars...)
     #=
     Creates a symbolic expression for the rate at which a given species is
     either produced or lost due to chemical reactions or transport.
@@ -727,7 +834,8 @@ function getrate(sp::Symbol; chemistry_on=true, transport_on=true, sepvecs=false
     Input:
         sp: species for which to get the rate 
         chemnet: chemistry reaction array
-        transportnet: transport network array
+        transportnet: vertical transport network array
+        transportnet_horiz: horizontal transport network array
         chem_species: species with active chemistry
         transport_species: species which transport
         chemistry_on: set to false to disallow chemical changes to species
@@ -748,15 +856,23 @@ function getrate(sp::Symbol; chemistry_on=true, transport_on=true, sepvecs=false
     if sepvecs == false
         rate = :(0.0)
         if issubset([sp], GV.chem_species) && chemistry_on
-            rate = :($rate 
-                     + $(production_rate(sp, GV.chemnet, sepvecs=sepvecs)) 
-                     - $(loss_rate(sp, GV.chemnet, sepvecs=sepvecs)) 
+            # rate = :($rate 
+            #          + $(production_rate(sp, GV.chemnet, sepvecs=sepvecs)) 
+            #          - $(loss_rate(sp, GV.chemnet, sepvecs=sepvecs)) 
+            rate = :($rate
+                     + $(production_rate(sp, GV.chemnet, sepvecs=sepvecs))
+                     - $(loss_rate(sp, GV.chemnet, sepvecs=sepvecs))
                     )
         end
         if issubset([sp], GV.transport_species) && transport_on
-            rate = :($rate 
-                     + $(production_rate(sp, GV.transportnet, sepvecs=sepvecs)) 
+            # rate = :($rate 
+            #          + $(production_rate(sp, GV.transportnet, sepvecs=sepvecs)) 
+            #          - $(loss_rate(sp, GV.transportnet, sepvecs=sepvecs))
+            rate = :($rate
+                     + $(production_rate(sp, GV.transportnet, sepvecs=sepvecs))
                      - $(loss_rate(sp, GV.transportnet, sepvecs=sepvecs))
+                     + $(production_rate(sp, transportnet_horiz, sepvecs=sepvecs))
+                     - $(loss_rate(sp, transportnet_horiz, sepvecs=sepvecs))
                     )
         end
         return rate
@@ -770,8 +886,12 @@ function getrate(sp::Symbol; chemistry_on=true, transport_on=true, sepvecs=false
         end
         
         if issubset([sp], GV.transport_species) && transport_on
-            transprod_rate = production_rate(sp, GV.transportnet, sepvecs=sepvecs)
-            transloss_rate = loss_rate(sp, GV.transportnet, sepvecs=sepvecs)
+            # transprod_rate = production_rate(sp, GV.transportnet, sepvecs=sepvecs)
+            # transloss_rate = loss_rate(sp, GV.transportnet, sepvecs=sepvecs)
+            transprod_rate = vcat(production_rate(sp, GV.transportnet, sepvecs=sepvecs),
+                                  production_rate(sp, transportnet_horiz, sepvecs=sepvecs))
+            transloss_rate = vcat(loss_rate(sp, GV.transportnet, sepvecs=sepvecs),
+                                  loss_rate(sp, transportnet_horiz, sepvecs=sepvecs))
         else
             transprod_rate = [:(0.0 + 0.0)]
             transloss_rate = [:(0.0 + 0.0)]
@@ -960,27 +1080,42 @@ function subtract_difflength(a::Array, b::Array)
     return sum(a[1:shared_size] .- b[1:shared_size]) + extra_a - extra_b
 end
 
-function update_Jrates!(n_cur_densities::Dict{Symbol, Array{ftype_ncur, 1}}; nlambda=2000, globvars...)
+function update_Jrates!(n_cur_densities::Dict{Symbol, Vector{Array{ftype_ncur}}},
+                        n_horiz::Int64; nlambda=2000, globvars...)
     #=
-    this function updates the photolysis rates stored in n_cur_densities to
-    reflect the altitude distribution of absorbing species.
+    Updates photolysis rates (Jrates) in n_cur_densities for each altitude and horizontal column
+    considering altitude distribution of absorbing species.
 
     Input:
         n_cur_densities: The present atmospheric state. This will be updated to include Jrates by this function.
+    n_cur_densities structure: 
+        Dict{Symbol, Vector{Array{ftype_ncur}}} (species -> [horizontal columns][altitudes])
     =#
 
     GV = values(globvars)
-    required = [:absorber, :dz, :crosssection, :Jratelist, :num_layers, :solarflux]
+    required = [:absorber, :dz, :crosssection, :Jratelist, :num_layers, :solarflux, :enable_horiz_transport]
     check_requirements(keys(GV), required)
 
-    solarabs = optical_depth(n_cur_densities; globvars...)
-    # solarabs now records the total optical depth of the atmosphere at
-    # each wavelength and altitude
+    # Calculate optical depth (now 2-D)
+    solarabs = optical_depth(n_cur_densities; n_horiz=n_horiz, globvars...)
+    # solarabs now records the total optical depth of the atmosphere at each wavelength and altitude
+
+     # Determine whether solar flux is provided per column.  If a single array is
+    # given, replicate it for all columns to maintain backwards compatibility.
+    flux_per_column = if GV.solarflux isa Vector
+        GV.solarflux
+    else
+        [GV.solarflux for _ in 1:n_horiz]
+    end
 
-    # actinic flux at each wavelength is solar flux diminished by total
-    # optical depth
-    for ialt in [1:GV.num_layers;]
-        solarabs[ialt] = GV.solarflux[:,2] .* exp.(-solarabs[ialt])
+    # Actinic flux at each wavelength and each horizontal column is the solar
+    # flux for that column diminished by the integrated optical depth above that
+    # layer.
+    for ihoriz in 1:n_horiz
+        col_flux = flux_per_column[ihoriz][:, 2]
+        for ialt in 1:GV.num_layers
+            solarabs[ihoriz][ialt] .= col_flux .* exp.(-solarabs[ihoriz][ialt])
+        end
     end
 
     # You can uncomment these to plot the extinction at each atmospheric level, but you have to feed it a specific Jrate
@@ -993,10 +1128,34 @@ function update_Jrates!(n_cur_densities::Dict{Symbol, Array{ftype_ncur, 1}}; nla
     # altitude times the actinic flux.
     # BLAS.dot includes an integration (sum) across wavelengths, i.e:
     # (a·b) = aa + ab + ab + bb etc that kind of thing
+
+    # Initialize and calculate Jrates independently for each horizontal column
     for j in GV.Jratelist
-        n_cur_densities[j] = zeros(GV.num_layers)
-        for ialt in [1:GV.num_layers;]
-            n_cur_densities[j][ialt] = ftype_ncur(BLAS.dot(nlambda, solarabs[ialt], 1, GV.crosssection[j][ialt+1], 1))
+        # Skip J-rates lacking cross sections or whose absorber species is absent
+        if !(haskey(GV.crosssection, j) && haskey(n_cur_densities, GV.absorber[j]))
+            continue
+        end
+
+        n_cur_densities[j] = [zeros(Float64, GV.num_layers) for ihoriz in 1:n_horiz]
+
+        for ihoriz in 1:n_horiz
+            for ialt in 1:GV.num_layers
+                n_cur_densities[j][ihoriz][ialt] = ftype_ncur(
+                    BLAS.dot(nlambda, solarabs[ihoriz][ialt], 1, GV.crosssection[j][ihoriz][ialt+1], 1) # updated update_Jrates! so Jrates integrate column-specific cross sections
+                )
+            end
+        end
+    end
+
+    # Verify identical Jrates when horizontal transport is disabled
+    if n_horiz > 1 && !GV.enable_horiz_transport
+        for j in GV.Jratelist
+            if haskey(n_cur_densities, j)
+                first = n_cur_densities[j][1]
+                for col in n_cur_densities[j][2:end]
+                    @assert isapprox(col, first; rtol=1e-8, atol=0.0) "Jrate mismatch across columns for $(j)"
+                end
+            end
         end
     end
 end
@@ -1032,7 +1191,7 @@ function effusion_velocity(Texo, m; globvars...)
 end
 
 # Nonthermal escape functions: 
-function escape_probability(sp, atmdict; globvars...)::Array
+function escape_probability(sp, atmdict, ihoriz; globvars...)::Array
     #=
     Returns an exponential profile of escape probability by altitude that accounts for collisions with the background 
     atmosphere. from Bethan Gregory, A and a for H. Could be redone for D, possibly.
@@ -1053,10 +1212,11 @@ function escape_probability(sp, atmdict; globvars...)::Array
                   "Venus"=>[0.868, 0.058]
                  )[GV.planet]
 
-    return params[1] .* exp.(-params[2] .* GV.collision_xsect[sp] .* column_density_above(n_tot(atmdict; GV.all_species, GV.dz); globvars...) ) 
+    totdens = n_tot(atmdict, ihoriz; GV.all_species, GV.dz)
+    return params[1] .* exp.(-params[2] .* GV.collision_xsect[sp] .* column_density_above(totdens; globvars...))
 end
 
-function escaping_hot_atom_production(sp, source_rxns, source_rxn_rc_funcs, atmdict, Mtot; returntype="array", globvars...)
+function escaping_hot_atom_production(sp, source_rxns, source_rxn_rc_funcs, atmdict, Mtot, ihoriz; returntype="array", globvars...)
     #=
     Solves the equation k[R1][R2] * P to get the total volume escape of hot atoms of species sp
     from the exobase region where P is the escape probability.
@@ -1066,6 +1226,7 @@ function escaping_hot_atom_production(sp, source_rxns, source_rxn_rc_funcs, atmd
         source_rxns: reaction network that will cause hot atoms to be produced
         atmdict: present atmospheric state dictionary
         Mtot: total atmospheric density array
+	ihoriz: Vertical column index
     Output: 
         array of production by altitude (rows) and reaction  (columns)
     =#
@@ -1075,13 +1236,14 @@ function escaping_hot_atom_production(sp, source_rxns, source_rxn_rc_funcs, atmd
                 :n_alt_index, :Tn, :Ti, :Te, :dz]
     check_requirements(keys(GV), required)
 
-    produced_hot = volume_rate_wrapper(sp, source_rxns, source_rxn_rc_funcs, atmdict, Mtot; returntype="array", zmax=GV.alt[end], globvars...) 
+    produced_hot = volume_rate_wrapper(sp, source_rxns, source_rxn_rc_funcs, atmdict, Mtot, ihoriz; returntype="array", zmax=GV.alt[end], globvars...) 
 
     # Returns an array where rows represent altitudes and columns are reactions. Multiplies each vertical profile (each column) by escape_probability. 
-    if returntype=="array" # Used within the code to easily calculate the total flux later on. 
-        return produced_hot .* escape_probability(sp, atmdict; globvars...)
+    if returntype=="array" # Used within the code to easily calculate the total flux later on.
+        return produced_hot .* escape_probability(sp, atmdict, ihoriz; globvars...)
     elseif returntype=="df" # Useful if you want to look at the arrays yourself.
-        return DataFrame(produced_hot .* escape_probability(sp, atmdict; globvars...), vec([format_chemistry_string(r[1], r[2]) for r in source_rxns]))
+        return DataFrame(produced_hot .* escape_probability(sp, atmdict, ihoriz; globvars...),
+                         vec([format_chemistry_string(r[1], r[2]) for r in source_rxns]))
     end
 end
 
@@ -1165,7 +1327,13 @@ function T_Mars(Tsurf, Tmeso, Texo; lapserate=-1.4e-5, z_meso_top=108e5, weird_T
     i_upper = findall(z->z > z_meso_top, GV.alt)
     i_meso_top = findfirst(z->z==z_meso_top, GV.alt)
     i_stitch_elec = findfirst(z->z==z_stitch_electrons, GV.alt)
+    if i_stitch_elec === nothing
+        i_stitch_elec = length(GV.alt)
+    end
     i_stitch_ions = findfirst(z->z==z_stitch_ions, GV.alt)
+    if i_stitch_ions === nothing
+        i_stitch_ions = length(GV.alt)
+    end
 
     function NEUTRALS()
         function upper_atmo_neutrals(z_arr)
@@ -1303,7 +1471,7 @@ function T_Venus(Tsurf::Float64, Tmeso::Float64, Texo::Float64, file_for_interp;
         Tn_interped = [interp_ion(a) for a in new_a];
         Tn[i_upper] .= Tn_interped # upper_atmo_neutrals(GV.alt[i_upper])
 
-        return Tn 
+        return Tn
     end 
 
     function ELECTRONS(new_a; spc="electron") 
@@ -1412,8 +1580,8 @@ function binary_dcoeff_inCO2(sp, T)
     return b
 end
 
-function boundaryconditions(fluxcoef_dict, atmdict, M; nonthermal=true, globvars...)
-    #= 
+function boundaryconditions(fluxcoef_dict, atmdict, M, n_horiz::Int64; nonthermal=true, globvars...)
+    #=
     Inputs:
         fluxcoef_dict: a dictionary containing the K and D flux coefficients for every species throughout
                        the atmosphere. Format species=>Array(length(all_species), length(alt)).
@@ -1421,15 +1589,16 @@ function boundaryconditions(fluxcoef_dict, atmdict, M; nonthermal=true, globvars
                        1st and last elements. 2nd and penultimate elements are for the edge bulk layers.
         atmdict: Atmospheric state dictionary, required for the nonthermal escape boundary condition.
         M: total atmospheric density, required for the nonthermal escape boundary condition.
+	n_horiz: Number of vertical columns in simulation
     Outputs:
         boundary conditions for species in a 2 x 2 matrix, format:
         [n_1 -> n_0, n_0 -> n_1;      
-         n_(nl) -> n_(nl+1), n_(nl+1) -> n_(n_l)]
+         n_(nl) -> n_(nl+1), n_(nl+1) -> n_(n_l)] for each vertical column
 
         where n_0 is the boundary layer from [-1 km, 1 km], n_1 is the first bulk layer from [1 km, 3 km],
         n_(nl) is the topmost bulk layer, and n_(nl+1) is the top boundary layer.
 
-        Form of the output is:
+        Form of the output, for each species for each vertical column is:
 
          Surface [↓, ↑;     [density-dependent, density-independent;    [#/s, #/cm³/s.;
          Top      ↑, ↓]      density-dependent, density-independent]     #/s, #/cm³/s]
@@ -1446,16 +1615,16 @@ function boundaryconditions(fluxcoef_dict, atmdict, M; nonthermal=true, globvars
         change recorded in other functions is always #/cm³/s. 
 
         FROM VENUS VERSION, MIKE:
-        Sign convention: The density-dependent terms (bc_dict[sp][:, 1]) are multiplied by -1 when the
+        Sign convention: The density-dependent terms (bc_dict[sp][ihoriz][:, 1]) are multiplied by -1 when the  
                          transport rates are computed in get_transport_PandL_rate. Density independent 
-                         terms (bc_dict[sp][:, 2]) are not.
+                         terms (bc_dict[sp][ihoriz][:, 2]) are not.
     =#
     
     GV = values(globvars)
     required = [:all_species, :speciesbclist, :dz, :planet]
     check_requirements(keys(GV), required)
     
-    bc_dict = Dict{Symbol, Array{ftype_ncur}}([s=>[0 0; 0 0] for s in GV.all_species])
+    bc_dict = Dict{Symbol, Vector{Array{ftype_ncur}}}([s=>[[0 0; 0 0] for ihoriz in 1:n_horiz] for s in GV.all_species])
 
     for sp in keys(GV.speciesbclist)
         try 
@@ -1464,136 +1633,139 @@ function boundaryconditions(fluxcoef_dict, atmdict, M; nonthermal=true, globvars
             println("No entry $(sp) in bcdict")
             continue
         end
- 
-        # DENSITY
-        try 
-            # lower boundary...
-            if GV.planet=="Mars"
-                n_lower = [fluxcoef_dict[sp][2, :][1], fluxcoef_dict[sp][1, :][2]*these_bcs["n"][1]]
-            elseif GV.planet=="Venus"
-                # get the eddy+molecular mixing velocities at the lower boundary of the atmosphere
-                v_lower_boundary_up = fluxcoef_dict[sp][1, # lower boundary cell, outside atmosphere
-                                                        2] # upward mixing velocity
-                v_lower_boundary_dn = fluxcoef_dict[sp][2, # bottom cell of atmosphere
-                                                        1] # downward mixing velocity
-
-                n_lower = [v_lower_boundary_dn, v_lower_boundary_up*these_bcs["n"][1]]
-            end
-            try
-                # TODO for Venus only, this note from Mike originally: 
-                # throw an error if density boundary condition
-                # is specified simultaneous with any flux or velocity condition
-                @assert all(x->!isnan(x), n_lower)
-                bc_dict[sp][1, :] .+= n_lower
-            catch y
-                if !isa(y, AssertionError)
-                    throw("Unhandled exception in lower density bc: $(y)")
-                end
-            end
 
-            # upper boundary...
+        for ihoriz in 1:n_horiz
+ 
+            # DENSITY
             try 
+                # lower boundary...
                 if GV.planet=="Mars"
-                    n_upper = [fluxcoef_dict[sp][end-1, :][2], fluxcoef_dict[sp][end, :][1]*these_bcs["n"][2]]
+                    n_lower = [fluxcoef_dict[sp][ihoriz][2, :][1], fluxcoef_dict[sp][ihoriz][1, :][2]*these_bcs["n"][ihoriz][1]]
                 elseif GV.planet=="Venus"
-                    # get the eddy+molecular mixing velocities at the upper boundary of the atmosphere
-                    v_upper_boundary_up = fluxcoef_dict[sp][end-1, # top cell of atmosphere
-                                                            2]     # upward mixing velocity
-                    v_upper_boundary_dn = fluxcoef_dict[sp][end, # upper boundary cell, outside atmosphere
-                                                            1]   # downward mixing velocity
+                    # get the eddy+molecular mixing velocities at the lower boundary of the atmosphere
+                    v_lower_boundary_up = fluxcoef_dict[sp][ihoriz][1, # lower boundary cell, outside atmosphere
+                                                                    2] # upward mixing velocity
+                    v_lower_boundary_dn = fluxcoef_dict[sp][ihoriz][2, # bottom cell of atmosphere
+                                                                    1] # downward mixing velocity
 
-                    n_upper = [v_upper_boundary_up, v_upper_boundary_dn*these_bcs["n"][2]]
-                    
+                    n_lower = [v_lower_boundary_dn, v_lower_boundary_up*these_bcs["n"][ihoriz][1]]
+                end
+                try
+                    # TODO for Venus only, this note from Mike originally: 
+                    # throw an error if density boundary condition
+                    # is specified simultaneous with any flux or velocity condition
+                    @assert all(x->!isnan(x), n_lower)
+                    bc_dict[sp][ihoriz][1, :] .+= n_lower
+                catch y
+                    if !isa(y, AssertionError)
+                        throw("Unhandled exception in lower density bc: $(y)")
+                    end
                 end
 
-                # TODO for Venus only, this note from Mike originally: 
-                # throw an error if density boundary condition
-                # is specified simultaneous with any flux or velocity condition
-                @assert all(x->!isnan(x), n_upper)
-                bc_dict[sp][2, :] .+= n_upper
-            catch y
-                if !isa(y, AssertionError)
-                    throw("Unhandled exception in upper density bc: $(y)")
+                # upper boundary...
+                try 
+                    if GV.planet=="Mars"
+                        n_upper = [fluxcoef_dict[sp][ihoriz][end-1, :][2], fluxcoef_dict[sp][ihoriz][end, :][1]*these_bcs["n"][ihoriz][2]]
+                    elseif GV.planet=="Venus"
+                        # get the eddy+molecular mixing velocities at the upper boundary of the atmosphere
+                        v_upper_boundary_up = fluxcoef_dict[sp][ihoriz][end-1, # top cell of atmosphere
+                                                                        2]     # upward mixing velocity
+                        v_upper_boundary_dn = fluxcoef_dict[sp][ihoriz][end, # upper boundary cell, outside atmosphere
+                                                                        1]   # downward mixing velocity
+
+                        n_upper = [v_upper_boundary_up, v_upper_boundary_dn*these_bcs["n"][ihoriz][2]]
+                    
+                    end
+
+                    # TODO for Venus only, this note from Mike originally: 
+                    # throw an error if density boundary condition
+                    # is specified simultaneous with any flux or velocity condition
+                    @assert all(x->!isnan(x), n_upper)
+                    bc_dict[sp][ihoriz][2, :] .+= n_upper
+                catch y
+                    if !isa(y, AssertionError)
+                        throw("Unhandled exception in upper density bc: $(y)")
+                    end
                 end
-            end
-        catch y
-            if !isa(y, KeyError)
-                throw("Unhandled exception in density bcs for $(sp): $(y)")
-            end
-        end
-    
-        # FLUX 
-        try 
-            # lower boundary...
-            if GV.planet=="Mars"
-                f_lower = [0, -these_bcs["f"][1]/GV.dz]
-            elseif GV.planet=="Venus"
-                f_lower = [0, these_bcs["f"][1]/GV.dz]
-                #             ^ no (-) sign, negative flux at lower boundary represents loss to surface
-            end
-            try        
-                @assert all(x->!isnan(x), f_lower)
-                bc_dict[sp][1, :] .+= f_lower
             catch y
-                if !isa(y, AssertionError)
-                    throw("Unhandled exception in lower flux bc: $(y)")
+                if !isa(y, KeyError)
+                    throw("Unhandled exception in density bcs for $(sp): $(y)")
                 end
             end
+    
+            # FLUX 
             try 
-                # upper boundary...
-                f_upper = [0, -these_bcs["f"][2]/GV.dz]
-                #             ^ (-) sign needed so that positive flux at upper boundary represents loss to space
-                #             (see "Sign convention" note above)
-                @assert all(x->!isnan(x), f_upper)
-                bc_dict[sp][2, :] .+= f_upper
+                # lower boundary...
+                if GV.planet=="Mars"
+                    f_lower = [0, -these_bcs["f"][ihoriz][1]/GV.dz]
+                elseif GV.planet=="Venus"
+                    f_lower = [0, these_bcs["f"][ihoriz][1]/GV.dz]
+                    #             ^ no (-) sign, negative flux at lower boundary represents loss to surface
+                end
+                try        
+                    @assert all(x->!isnan(x), f_lower)
+                    bc_dict[sp][ihoriz][1, :] .+= f_lower
+                catch y
+                    if !isa(y, AssertionError)
+                        throw("Unhandled exception in lower flux bc: $(y)")
+                    end
+                end
+                try 
+                    # upper boundary...
+                    f_upper = [0, -these_bcs["f"][ihoriz][2]/GV.dz]
+                    #             ^ (-) sign needed so that positive flux at upper boundary represents loss to space
+                    #             (see "Sign convention" note above)
+                    @assert all(x->!isnan(x), f_upper)
+                    bc_dict[sp][ihoriz][2, :] .+= f_upper
+                catch y
+                    if !isa(y, AssertionError)
+                        throw("Unhandled exception in upper flux bc: $(y)")
+                    end
+                end
             catch y
-                if !isa(y, AssertionError)
-                    throw("Unhandled exception in upper flux bc: $(y)")
+                if !isa(y, KeyError)
+                    throw("Unhandled exception in flux bcs for $(sp)")
                 end
             end
-        catch y
-            if !isa(y, KeyError)
-                throw("Unhandled exception in flux bcs for $(sp)")
-            end
-        end
     
-        # VELOCITY
-        try 
-            # lower boundary...
-            if GV.planet=="Mars" 
-                v_lower = [these_bcs["v"][1]/GV.dz, 0]
-            elseif GV.planet=="Venus"
-                v_lower = [-these_bcs["v"][1]/GV.dz, 0]
-            #          ^ (-) sign needed so that negative velocity at lower boundary represents loss to surface
-            #          (see "Sign convention" note above)
-            end
+            # VELOCITY
+            try 
+                # lower boundary...
+                if GV.planet=="Mars" 
+                    v_lower = [these_bcs["v"][ihoriz][1]/GV.dz, 0]
+                elseif GV.planet=="Venus"
+                    v_lower = [-these_bcs["v"][ihoriz][1]/GV.dz, 0]
+                #          ^ (-) sign needed so that negative velocity at lower boundary represents loss to surface
+                #          (see "Sign convention" note above)
+                end
 
-            try
-                @assert all(x->!isnan(x), v_lower)
-                bc_dict[sp][1, :] .+= v_lower
-            catch y
-                if !isa(y, AssertionError)
-                    throw("Unhandled exception in lower velocity bc: $(y)")
+                try
+                    @assert all(x->!isnan(x), v_lower)
+                    bc_dict[sp][ihoriz][1, :] .+= v_lower
+                catch y
+                    if !isa(y, AssertionError)
+                        throw("Unhandled exception in lower velocity bc: $(y)")
+                    end
                 end
-            end
 
-            try 
-                # upper boundary...
-                v_upper = [these_bcs["v"][2]/GV.dz, 0]
-                #          ^ no (-) sign needed,  positive velocity at upper boundary represents loss to space
-                #          (see "Sign convention" note above)
-                @assert all(x->!isnan(x), v_upper)
-                bc_dict[sp][2, :] .+= v_upper
+                try 
+                    # upper boundary...
+                    v_upper = [these_bcs["v"][ihoriz][2]/GV.dz, 0]
+                    #          ^ no (-) sign needed,  positive velocity at upper boundary represents loss to space
+                    #          (see "Sign convention" note above)
+                    @assert all(x->!isnan(x), v_upper)
+                    bc_dict[sp][ihoriz][2, :] .+= v_upper
+                catch y
+                    if !isa(y, AssertionError)
+                        throw("Unhandled exception in lower velocity bc: $(y)")
+                    end
+                end
             catch y
-                if !isa(y, AssertionError)
-                    throw("Unhandled exception in lower velocity bc: $(y)")
+                if !isa(y, KeyError)
+                    throw("Unhandled exception in velocity bcs for $(sp)")
                 end
             end
-        catch y
-            if !isa(y, KeyError)
-                throw("Unhandled exception in velocity bcs for $(sp)")
-            end
-        end 
+        end
     end
     
     # SPECIAL CASE: add on the non-thermal escape for H and D. 
@@ -1601,10 +1773,13 @@ function boundaryconditions(fluxcoef_dict, atmdict, M; nonthermal=true, globvars
         required = [:hot_H_network, :hot_D_network, :hot_H_rc_funcs, :hot_D_rc_funcs, 
                     :hot_H2_network, :hot_H2_rc_funcs, :hot_HD_network, :hot_HD_rc_funcs, :Jratedict]
         check_requirements(keys(GV), required)
-        prod_hotH = escaping_hot_atom_production(:H, GV.hot_H_network, GV.hot_H_rc_funcs, atmdict, M; globvars...)
-        prod_hotD = escaping_hot_atom_production(:D, GV.hot_D_network, GV.hot_D_rc_funcs, atmdict, M; globvars...)
-        prod_hotH2 = escaping_hot_atom_production(:H2, GV.hot_H2_network, GV.hot_H2_rc_funcs, atmdict, M; globvars...)
-        prod_hotHD = escaping_hot_atom_production(:HD, GV.hot_HD_network, GV.hot_HD_rc_funcs, atmdict, M; globvars...)
+
+        for ihoriz in 1:n_horiz
+	    if :H in keys(atmdict) && :D in keys(atmdict) && :H2 in keys(atmdict) && :HD in keys(atmdict) 
+               prod_hotH = escaping_hot_atom_production(:H, GV.hot_H_network, GV.hot_H_rc_funcs, atmdict, M, ihoriz; globvars...)
+               prod_hotD = escaping_hot_atom_production(:D, GV.hot_D_network, GV.hot_D_rc_funcs, atmdict, M, ihoriz; globvars...)
+               prod_hotH2 = escaping_hot_atom_production(:H2, GV.hot_H2_network, GV.hot_H2_rc_funcs, atmdict, M, ihoriz; globvars...)
+               prod_hotHD = escaping_hot_atom_production(:HD, GV.hot_HD_network, GV.hot_HD_rc_funcs, atmdict, M, ihoriz; globvars...)
 
         # DIAGNOSTIC: produced hot H
         # if :results_dir in keys(GV)
@@ -1618,15 +1793,104 @@ function boundaryconditions(fluxcoef_dict, atmdict, M; nonthermal=true, globvars
         #     close(fig)
         # end
 
-        bc_dict[:H][2, :] .+= [0, -(1/GV.dz)*nonthermal_escape_flux(GV.hot_H_network, prod_hotH; returntype="number", globvars...)]
-        bc_dict[:D][2, :] .+= [0, -(1/GV.dz)*nonthermal_escape_flux(GV.hot_D_network, prod_hotD; returntype="number", globvars...)]
-        bc_dict[:H2][2, :] .+= [0, -(1/GV.dz)*nonthermal_escape_flux(GV.hot_H2_network, prod_hotH2; returntype="number", globvars...)]
-        bc_dict[:HD][2, :] .+= [0, -(1/GV.dz)*nonthermal_escape_flux(GV.hot_HD_network, prod_hotHD; returntype="number", globvars...)]
-    end 
+                bc_dict[:H][ihoriz][2, :] .+= [0, -(1/GV.dz)*nonthermal_escape_flux(GV.hot_H_network, prod_hotH; returntype="number", globvars...)]
+            	bc_dict[:D][ihoriz][2, :] .+= [0, -(1/GV.dz)*nonthermal_escape_flux(GV.hot_D_network, prod_hotD; returntype="number", globvars...)]
+            	bc_dict[:H2][ihoriz][2, :] .+= [0, -(1/GV.dz)*nonthermal_escape_flux(GV.hot_H2_network, prod_hotH2; returntype="number", globvars...)]
+            	bc_dict[:HD][ihoriz][2, :] .+= [0, -(1/GV.dz)*nonthermal_escape_flux(GV.hot_HD_network, prod_hotHD; returntype="number", globvars...)]
+	 #   else
+	 #       println("At least one of H, D, H2 and HD is not in the model.",'\n')
+            end
+	end
+    end
     return bc_dict
 end
 
-function Dcoef_neutrals(z, sp::Symbol, b, atmdict::Dict{Symbol, Vector{ftype_ncur}}; globvars...)
+# function boundaryconditions_horiz(globvars)
+function boundaryconditions_horiz(
+    atmdict::Dict{Symbol, Vector{Array{ftype_ncur}}},
+    horiz_wind_v::Vector{Vector{Float64}},
+    n_horiz::Int64;
+    cyclic::Bool=true,
+    globvars...
+)
+    #= 
+    Inputs:
+        M: total atmospheric density, required for the nonthermal escape boundary condition.
+    Outputs:
+        boundary conditions for species in a 2 x 2 matrix, format:  
+        [n_1 -> n_0, n_0 -> n_1;      
+         n_(nhoriz) -> n_(nhoriz+1), n_(nhoriz+1) -> n_(nhoriz)] for each bulk layer altitude bin
+
+        where n_0 is outside the model behind the back edge, n_1 is the first vertical column (ihoriz=1),
+        n_(nhoriz) is the front-most verical column (ihoriz=n_horiz), and n_(nhoriz+1) is outside the model in front of the front edge.
+
+        Form of the output, for each species for each vertical column is:
+
+         Back edge   [←, →;     [density-dependent, density-independent;    [#/s, #/cm³/s.;
+         Front edge   →, ←]      density-dependent, density-independent]     #/s, #/cm³/s]
+         where ← is backwards from higher to lower values of ihoriz; → is forwards from lower to higher
+
+        Each row has two elements:
+            1st element: inside model  -> outside model (depends on species concentration in cell)
+            2nd element: outside model -> inside moel (independent of species concentration in cell)
+
+            note, technically, these are chemical equations.
+
+        More specifically, when the return value of this function is used in other functions, the first
+        element in each row will eventually be multiplied by a density taken from the atmospheric 
+        state dictionary, and the second element will be used as-is. That way, eventually the total
+        change recorded in other functions is always #/cm³/s. 
+
+        FROM VENUS VERSION, MIKE:
+        Sign convention: The density-dependent terms (bc_dict[sp][ialt][:, 1]) are multiplied by -1 when the 
+                         transport rates are computed in get_transport_PandL_rate. Density independent
+                         terms (bc_dict[sp][ialt][:, 2]) are not.
+
+        However, please note that the model is currently set up to use zero flux edge boundary conditions only. The above comments have been left for future development and flexibility.
+        By default the dictionary ``speciesbclist_horiz`` in ``MODEL_SETUP.jl`` supplies
+        zero-flux edge conditions for all species.  You may override these values
+        to impose custom influxes or outfluxes at either edge.  The sign
+        convention is the same as for vertical boundary conditions: positive
+        numbers inject material and negative numbers remove it.
+    =#
+    
+    GV = values(globvars)
+    required = [:all_species, :speciesbclist_horiz, :dx, :planet]
+    check_requirements(keys(GV), required)
+    
+    # bc_dict_horiz = Dict{Symbol, Vector{Array{ftype_ncur}}}([s=>[[0.0 0.0; 0.0 0.0] for ialt in 1:GV.num_layers] for s in GV.all_species])
+    bc_dict_horiz = Dict{Symbol, Vector{Array{ftype_ncur}}}(
+        [s => [fill(0.0, 2, 2) for ialt in 1:GV.num_layers] for s in GV.all_species]
+    )
+
+    for sp in keys(GV.speciesbclist_horiz)
+        these_bcs_horiz = GV.speciesbclist_horiz[sp]
+
+        for ialt in 1:GV.num_layers
+            if cyclic
+                # Periodic domain: no exchange with the environment
+                bc_dict_horiz[sp][ialt] .= 0.0
+            else
+                back_flux  = these_bcs_horiz["f"][1][ialt]
+                front_flux = these_bcs_horiz["f"][2][ialt]
+                # if GV.planet == "Mars"
+                #     f_backedge = [0, -back_flux / GV.dx]
+                # elseif GV.planet == "Venus"
+                #     f_backedge = [0, back_flux / GV.dx]
+                # end
+                f_backedge  = [0, -back_flux / GV.dx]
+                f_frontedge = [0,  front_flux / GV.dx]
+                bc_dict_horiz[sp][ialt][1, :] .+= f_backedge
+                bc_dict_horiz[sp][ialt][2, :] .+= f_frontedge
+            end
+        end
+    end
+    
+
+    return bc_dict_horiz
+end
+
+function Dcoef_neutrals(z, sp::Symbol, b, atmdict::Dict{Symbol, Vector{ftype_ncur}}; ihoriz=1, globvars...)
     #=
     Calculate the basic diffusion coefficient, AT^s/n.
     Inputs:
@@ -1644,13 +1908,13 @@ function Dcoef_neutrals(z, sp::Symbol, b, atmdict::Dict{Symbol, Vector{ftype_ncu
     check_requirements(keys(GV), required)
 
     if (typeof(z)==Float64) & (typeof(b)==Float64)
-        return b ./ n_tot(atmdict, z; GV.all_species, GV.n_alt_index)
-    else 
-        return b ./ n_tot(atmdict; GV.all_species, GV.n_alt_index)
+        return b ./ n_tot(atmdict, z, ihoriz; GV.all_species, GV.n_alt_index)
+    else
+        return b ./ n_tot(atmdict, ihoriz; GV.all_species, GV.n_alt_index)
     end
 end
 
-function Dcoef!(D_arr, T_arr, sp::Symbol, atmdict::Dict{Symbol, Vector{ftype_ncur}}; globvars...) 
+function Dcoef!(D_arr, T_arr_2D, sp::Symbol, atmdict::Dict{Symbol, Vector{Array{ftype_ncur}}}, n_horiz::Int64; globvars...)
     #=
     Calculates the molecular diffusion coefficient for an atmospheric layer.
     For neutrals, returns D = AT^s/n, from Banks and Kockarts Aeronomy, part B, pg 41, eqn 
@@ -1661,60 +1925,83 @@ function Dcoef!(D_arr, T_arr, sp::Symbol, atmdict::Dict{Symbol, Vector{ftype_ncu
 
     Inputs:
         D_arr: the container for the diffusion coefficients for ONE species.
-        T_arr: temperature (K). Neutral temp for neutrals, plasma temp for ions.
+               D_arr[ihoriz] is a 1D array with altitude for column ihoriz.
+        T_arr_2D: 2D temperature (K), shape (n_horiz, num_layers+2).
+                  Neutral temp if sp is neutral; plasma temp if sp is ion.
         sp: whichever species we are calculating for
-        atmdict: state of the atmosphere; should include boundary layers, i.e. be the result of calling atmdict_with_boundary_layers.
-        bcdict: Boundary conditions dictionary specified in parameters file
+        atmdict: state of the atmosphere; should include boundary layers, i.e.
+                 be the result of calling atmdict_with_boundary_layers.
+        n_horiz: number of vertical columns
     Outputs:
-        D_arr: An array of the diffusion coefficients by altitude for species
+        D_arr: The same container, now filled with the diffusion coefficients by altitude
+               for this species, for each column.
+
     =#
 
     GV = values(globvars)
-    required = [:all_species, :molmass, :neutral_species, :n_alt_index, :polarizability, :q, :speciesbclist, :use_ambipolar, :use_molec_diff]
+    required = [
+        :all_species, :molmass, :neutral_species, :n_alt_index, :polarizability,
+        :q, :speciesbclist, :use_ambipolar, :use_molec_diff
+    ]
     check_requirements(keys(GV), required)
 
-    if GV.use_molec_diff==true
-        # Calculate as if it was a neutral - not using function above because this is faster than going into 
-        # the function and using an if/else block since we know we'll always have vectors in this case.
-        # This equation is: D = b/n 
-        D_arr[:] .= (binary_dcoeff_inCO2(sp, T_arr)) ./ n_tot(atmdict; GV.all_species, GV.n_alt_index)
-    else
-        D_arr[:] .= 0 
-    end
-
-    # If an ion, overwrite with the ambipolar diffusion
-    if GV.use_ambipolar==true
-        if charge_type(sp) == "ion"
-            # a place to store the density array and nu_in
-            species_density = zeros(size(T_arr))
-            sum_nu_in = zeros(size(T_arr))
-
-            # mi = GV.molmass[sp] .* mH
-            # create the sum of nu_in. Note that this depends on density, but we only have density for the real layers,
-            # so we have to assume the density at the boundary layers is the same as at the real layers.
-            for n in GV.neutral_species
-                species_density = atmdict[n]
-
-                # This sets the species density to a boundary condition if it exists. 
-                if haskey(GV.speciesbclist, n)
-                    if haskey(GV.speciesbclist[n], "n") 
-                        if !isnan(GV.speciesbclist[n]["n"][1])
-                            species_density[1] = GV.speciesbclist[n]["n"][1]
-                        end
-                        if !isnan(GV.speciesbclist[n]["n"][2]) # currently this should never apply.
-                            species_density[end] = GV.speciesbclist[n]["n"][2]
+    # Loop over each vertical column
+    for ihoriz in 1:n_horiz
+
+        # Extract this column's temperature profile
+        local T_col = T_arr_2D[ihoriz, :]
+
+        # If using molecular diffusion, compute D
+        if GV.use_molec_diff == true
+            # Calculate as if it was a neutral - not using function above because this is faster than going into 
+            # the function and using an if/else block since we know we'll always have vectors in this case.
+            # This equation is: D = b/n
+            D_arr[ihoriz] .= (binary_dcoeff_inCO2(sp, T_col)) ./ n_tot(atmdict, ihoriz; GV.all_species, GV.n_alt_index)
+        else
+            D_arr[ihoriz] .= 0 
+        end
+
+        # If ambipolar diffusion is turned on, and this is an ion, overwrite with ambipolar D
+        if GV.use_ambipolar==true
+            if charge_type(sp) == "ion"
+                # Prepare arrays to store the sum over collisions
+                # (We build them for each column to match T_col's shape.)
+                species_density = zeros(size(T_col))
+                sum_nu_in      = zeros(size(T_col))
+
+                # mi = GV.molmass[sp] .* mH
+                # create the sum of nu_in. Note that this depends on density, but we only have density for the real layers,
+                # so we have to assume the density at the boundary layers is the same as at the real layers.
+                for n in GV.neutral_species
+                    # Add the neutral’s density profile for this column
+                    species_density .= atmdict[n][ihoriz]
+
+                    # Optionally override with boundary condition if specified
+                    if haskey(GV.speciesbclist, n)
+                        if haskey(GV.speciesbclist[n], "n")
+                            # lower boundary
+                            if !isnan(GV.speciesbclist[n]["n"][ihoriz][1])
+                                species_density[1] = GV.speciesbclist[n]["n"][ihoriz][1]
+                            end
+                            # upper boundary 
+                            if !isnan(GV.speciesbclist[n]["n"][ihoriz][2])
+                                species_density[end] = GV.speciesbclist[n]["n"][ihoriz][2]
+                            end
                         end
                     end
+
+                    sum_nu_in .+= 2π .* sqrt.(
+                        (GV.polarizability[n] .* (GV.q^2)) ./
+                        reduced_mass(GV.molmass[sp], GV.molmass[n])
+                    ) .* species_density
                 end
-                
-                sum_nu_in .+= 2 .* pi .* (((GV.polarizability[n] .* GV.q .^ 2) ./ reduced_mass(GV.molmass[sp], GV.molmass[n])) .^ 0.5) .* species_density
 
+                # Finally set D_ambipolar = kB * T / (m_sp * sum_nu_in)
+                D_arr[ihoriz] .= (kB .* T_col) ./ (GV.molmass[sp] .* mH .* sum_nu_in)
             end
-            
-            D_arr .= (kB .* T_arr) ./ (GV.molmass[sp] .* mH .* sum_nu_in)
-
         end
-    end
+
+    end # for ihoriz
     return D_arr
 end
 
@@ -1742,7 +2029,7 @@ diffparams(s) = get(Dict(:H=>[8.4, 0.597], :H2=>[2.23, 0.75],
                          :Dpl=>[5.98, 0.597], :HDpl=>[1.84, 0.75]),
                         s,[1.0, 0.75])
 
-function fluxcoefs(sp::Symbol, Kv, Dv, H0v; globvars...)
+function fluxcoefs(sp::Symbol, Kv, Dv, H0v, ihoriz::Int64; globvars...)
     #= 
     base function to generate flux coefficients of the transport network. 
     
@@ -1755,10 +2042,11 @@ function fluxcoefs(sp::Symbol, Kv, Dv, H0v; globvars...)
         for all the following, length = num_layers 
         Kv: eddy diffusion coefficient
         Dv: molecular diffusion coefficient
-        Tv_n: neutral temperature
-        Tv_p: plasma temperature
+        Tv_n: neutral temperature (2D, size num_layers × n_horiz)
+        Tv_p: plasma temperature (2D, size num_layers × n_horiz)
         Hsv: scale height by species
         H0v: mean atmospheric scale height
+        ihoriz: vertical column index
     Outputs:
         Arrays of coefficients (units 1/s) at each atmospheric layer for downward and upward flux.
         Note that even though it's defined as being between a layer and the one above or below, the value is 
@@ -1792,26 +2080,36 @@ function fluxcoefs(sp::Symbol, Kv, Dv, H0v; globvars...)
     Hsu = zeros(GV.n_all_layers)
     H0u = zeros(GV.n_all_layers)
 
-    # Calculate the coefficients between this layer and the lower layer. 
-    Dl[2:end] = @. (Dv[sp][1:end-1] + Dv[sp][2:end]) /  2.0
-    Kl[2:end] = @. (Kv[1:end-1] + Kv[2:end]) / 2.0
-    Tl_n[2:end] = @. (GV.Tn[1:end-1] + GV.Tn[2:end]) / 2.0
-    Tl_p[2:end] = @. (GV.Tp[1:end-1] + GV.Tp[2:end]) / 2.0
-    dTdzl_n[2:end] = @. (GV.Tn[2:end] - GV.Tn[1:end-1]) / GV.dz
-    dTdzl_p[2:end] = @. (GV.Tp[2:end] - GV.Tp[1:end-1]) / GV.dz
-    Hsl[2:end] = @. (GV.Hs_dict[sp][1:end-1] + GV.Hs_dict[sp][2:end]) / 2.0
-    H0l[2:end] = @. (H0v[charge_type(sp)][1:end-1] + H0v[charge_type(sp)][2:end]) / 2.0
+    # Local column references
+    Tn_col = GV.Tn[ihoriz, :]   # 1D array for neutrals
+    Tp_col = GV.Tp[ihoriz, :]   # 1D array for plasma
+    Hs_col = GV.Hs_dict[sp][ihoriz]
+
+    # Retrieve arrays specific to this vertical column
+    thisD  = Dv[sp][ihoriz]
+    thisK  = Kv[ihoriz]
+    thisH0 = H0v[charge_type(sp)][ihoriz]
+
+    # Calculate the coefficients between this layer and the lower layer.
+    Dl[2:end]     = @. (thisD[1:end-1] + thisD[2:end]) /  2.0
+    Kl[2:end]     = @. (thisK[1:end-1] + thisK[2:end]) / 2.0
+    Tl_n[2:end]   = @. (Tn_col[1:end-1] + Tn_col[2:end]) / 2.0
+    Tl_p[2:end]   = @. (Tp_col[1:end-1] + Tp_col[2:end]) / 2.0
+    dTdzl_n[2:end]= @. (Tn_col[2:end] - Tn_col[1:end-1]) / GV.dz
+    dTdzl_p[2:end]= @. (Tp_col[2:end] - Tp_col[1:end-1]) / GV.dz
+    Hsl[2:end]    = @. (Hs_col[1:end-1] + Hs_col[2:end]) / 2.0
+    H0l[2:end]    = @. (thisH0[1:end-1] + thisH0[2:end]) / 2.0
 
     if GV.planet=="Mars"
         # Handle the lower boundary layer:
-        Dl[1] = @. (1 + Dv[sp][1]) /  2.0
-        Kl[1] = @. (1 + Kv[1]) / 2.0
-        Tl_n[1] = @. (1 + GV.Tn[1]) / 2.0
-        Tl_p[1] = @. (1 + GV.Tp[1]) / 2.0
-        dTdzl_n[1] = @. (GV.Tn[1] - 1) / GV.dz
-        dTdzl_p[1] = @. (GV.Tp[1] - 1) / GV.dz
-        Hsl[1] = @. (1 + GV.Hs_dict[sp][1]) / 2.0
-        H0l[1] = @. (1 + H0v[charge_type(sp)][1]) / 2.0
+        Dl[1]      = @. (1 + thisD[1]) /  2.0
+        Kl[1]      = @. (1 + thisK[1]) / 2.0
+        Tl_n[1]    = @. (1 + Tn_col[1]) / 2.0
+        Tl_p[1]    = @. (1 + Tp_col[1]) / 2.0
+        dTdzl_n[1] = @. (Tn_col[1] - 1) / GV.dz
+        dTdzl_p[1] = @. (Tp_col[1] - 1) / GV.dz
+        Hsl[1]     = @. (1 + Hs_col[1]) / 2.0
+        H0l[1]     = @. (1 + thisH0[1]) / 2.0
     elseif GV.planet=="Venus"
         # Downward transport away from the lower boundary layer, which is outside the model
         # These should never be used but we need to fill the array
@@ -1826,25 +2124,25 @@ function fluxcoefs(sp::Symbol, Kv, Dv, H0v; globvars...)
     end
 
     # Upward transport from each altitude to the cell above
-    Du[1:end-1] = @. (Dv[sp][1:end-1] + Dv[sp][2:end]) /  2.0
-    Ku[1:end-1] = @. (Kv[1:end-1] + Kv[2:end]) / 2.0
-    Tu_n[1:end-1] = @. (GV.Tn[1:end-1] + GV.Tn[2:end]) / 2.0
-    Tu_p[1:end-1] = @. (GV.Tp[1:end-1] + GV.Tp[2:end]) / 2.0
-    dTdzu_n[1:end-1] = @. (GV.Tn[2:end] - GV.Tn[1:end-1]) / GV.dz
-    dTdzu_p[1:end-1] = @. (GV.Tp[2:end] - GV.Tp[1:end-1]) / GV.dz
-    Hsu[1:end-1] = @. (GV.Hs_dict[sp][1:end-1] + GV.Hs_dict[sp][2:end]) / 2.0
-    H0u[1:end-1] = @. (H0v[charge_type(sp)][1:end-1] + H0v[charge_type(sp)][2:end]) / 2.0
+    Du[1:end-1]     = @. (thisD[1:end-1] + thisD[2:end]) /  2.0
+    Ku[1:end-1]     = @. (thisK[1:end-1] + thisK[2:end]) / 2.0
+    Tu_n[1:end-1]   = @. (Tn_col[1:end-1] + Tn_col[2:end]) / 2.0
+    Tu_p[1:end-1]   = @. (Tp_col[1:end-1] + Tp_col[2:end]) / 2.0
+    dTdzu_n[1:end-1]= @. (Tn_col[2:end] - Tn_col[1:end-1]) / GV.dz
+    dTdzu_p[1:end-1]= @. (Tp_col[2:end] - Tp_col[1:end-1]) / GV.dz
+    Hsu[1:end-1]    = @. (Hs_col[1:end-1] + Hs_col[2:end]) / 2.0
+    H0u[1:end-1]    = @. (thisH0[1:end-1] + thisH0[2:end]) / 2.0
 
     if GV.planet=="Mars"
         # Handle upper boundary layer:
-        Du[end] = @. (Dv[sp][end] + 1) /  2.0
-        Ku[end] = @. (Kv[end] + 1) / 2.0
-        Tu_n[end] = @. (GV.Tn[end] + 1) / 2.0
-        Tu_p[end] = @. (GV.Tp[end] + 1) / 2.0
-        dTdzu_n[end] = @. (1 - GV.Tn[end]) / GV.dz
-        dTdzu_p[end] = @. (1 - GV.Tp[end]) / GV.dz
-        Hsu[end] = @. (GV.Hs_dict[sp][end] + 1) / 2.0
-        H0u[end] = @. (H0v[charge_type(sp)][end] + 1) / 2.0
+        Du[end]      = @. (thisD[end] + 1) /  2.0
+        Ku[end]      = @. (thisK[end] + 1) / 2.0
+        Tu_n[end]    = @. (Tn_col[end] + 1) / 2.0
+        Tu_p[end]    = @. (Tp_col[end] + 1) / 2.0
+        dTdzu_n[end] = @. (1 - Tn_col[end]) / GV.dz
+        dTdzu_p[end] = @. (1 - Tp_col[end]) / GV.dz
+        Hsu[end]     = @. (Hs_col[end] + 1) / 2.0
+        H0u[end]     = @. (thisH0[end] + 1) / 2.0
     elseif GV.planet=="Venus"
         # Upwards flux from the upper boundary layer, which is outside the model
         # These should never be used but we need to fill the array
@@ -1891,7 +2189,7 @@ function fluxcoefs(sp::Symbol, Kv, Dv, H0v; globvars...)
             sumeddyu .- gravthermalu # up; negative because gravity points down. I think that's why.
 end
 
-function fluxcoefs(species_list::Vector, K, D, H0; globvars...) 
+function fluxcoefs(species_list::Vector, K, D, H0, n_horiz::Int64; globvars...) 
     #=
     New optimized version of fluxcoefs that calls the lower level version of fluxcoefs,
     producing a dictionary that contains both up and down flux coefficients for each layer of
@@ -1901,7 +2199,7 @@ function fluxcoefs(species_list::Vector, K, D, H0; globvars...)
     Here, D and Hs depend on the current atmospheric densities, and need to be pre-calculated
     within the upper level function which calls this one.
     The parameters below which vary by species are dictionaries, and those that are arrays
-    don't depend on the species. All profiles are by altitude. All lengths are the same 
+    don't depend on the species. All profiles are by altitude. All lengths are the same
     as for the alt variable (full altitude grid including boundary layers).
     
     Inputs:
@@ -1924,38 +2222,178 @@ function fluxcoefs(species_list::Vector, K, D, H0; globvars...)
     check_requirements(keys(GV), required)
     
     # the return dictionary: Each species has 2 entries for every layer of the atmosphere.
-    fluxcoef_dict = Dict{Symbol, Array{ftype_ncur}}([s=>fill(0., GV.n_all_layers, 2) for s in species_list])
+    fluxcoef_dict = Dict{Symbol, Vector{Array{ftype_ncur}}}([s=>[fill(0., GV.n_all_layers, 2) for ihoriz in 1:n_horiz] for s in species_list])
 
     for s in species_list
-        layer_below_coefs, layer_above_coefs = fluxcoefs(s, K, D, H0; globvars...)
-        fluxcoef_dict[s][:, 1] .= layer_below_coefs
-        fluxcoef_dict[s][:, 2] .= layer_above_coefs
+        for ihoriz in 1:n_horiz
+            layer_below_coefs, layer_above_coefs = fluxcoefs(s, K, D, H0, ihoriz; globvars...)
+            fluxcoef_dict[s][ihoriz][:, 1] .= layer_below_coefs
+            fluxcoef_dict[s][ihoriz][:, 2] .= layer_above_coefs
+        end
     end
 
     return fluxcoef_dict
 end
 
-function Keddy(z::Vector, nt::Vector; globvars...)
+# function fluxcoefs_horiz(species_list::Vector, horiz_wind_v::Vector{Vector{Float64}}, n_horiz::Int64; globvars...) 
+#     New optimized version of fluxcoefs that calls the lower level version of fluxcoefs,
+#     producing a dictionary that contains both up and down flux coefficients for each layer of
+#     the atmosphere including boundary layers. Created to optimize calls to this function
+#     during the solution of the production and loss equation.
+
+#     Here, D and Hs depend on the current atmospheric densities, and need to be pre-calculated
+#     within the upper level function which calls this one.
+#     The parameters below which vary by species are dictionaries, and those that are arrays
+#     don't depend on the species. All profiles are by altitude. All lengths are the same 
+#     as for the alt variable (full altitude grid including boundary layers).
+    
+#     Inputs:
+#         species_list: Species for which to generate transport coefficients. This allows the code to only do it for
+#                 transport species during the main simulation run, and for all species when trying to plot 
+#                 rate balances after the run.
+#         T_neutral: 1D neutral temperature profile
+#         T_plasma: the same, but for the plasma temperature
+#         K: Array; 1D eddy diffusion profile by altitude for current atmospheric state
+#         D: Dictionary (key=species); 1D molecular diffusion profiles for current atmospheric state
+#         H0: Dictionary (key="neutral" or "ion"); 1D mean atmospheric scale height profiles for each type
+#         Hs: Dictionary (key=species); 1D species scale height profiles
+#     Outputs:
+#         fluxcoef_dict: dictionary of flux coefficients of the form [flux down, flux up] by altitude 
+
+#     =#
+"""
+Compute horizontal transport coefficients for each species and column.
+
+Each entry ``fluxcoef_dict[s][i]`` contains a ``n_all_layers x 2`` matrix of
+coefficients linking column ``i`` to the column behind (column 1) and the column
+in front (column 2). Diffusion coefficients are averaged between neighbouring
+columns and scaled by ``dx²`` while advection uses an upwind scheme based on the
+provided horizontal wind profile.  Passing `cyclic=true` wraps the indices so
+that column 1 connects to column ``n_horiz`` and vice versa.
+"""
+function fluxcoefs_horiz(
+    species_list::Vector,
+    K::Vector{Vector{ftype_ncur}},
+    D::Dict{Symbol, Vector{Vector{ftype_ncur}}},
+    horiz_wind_v::Vector{Vector{Float64}},
+    n_horiz::Int64;
+    cyclic::Bool = true,
+    globvars...
+)
+    GV = values(globvars)
+    required = [:dx, :n_all_layers, :enable_horiz_transport]
+    check_requirements(keys(GV), required)
+    
+    # the return dictionary: Each species has 2 entries for every layer of the atmosphere.
+    # fluxcoef_horiz_dict = Dict{Symbol, Vector{Array{ftype_ncur}}}([s=>[fill(0., GV.n_all_layers, 2) for ihoriz in 1:n_horiz] for s in species_list])
+    fluxcoef_dict = Dict{Symbol, Vector{Array{ftype_ncur}}}(
+        [s => [zeros(ftype_ncur, GV.n_all_layers, 2) for _ in 1:n_horiz]
+         for s in species_list],
+    )
+
+    for s in species_list
+        for ihoriz in 1:n_horiz
+            if cyclic
+                behind_idx  = ihoriz == 1        ? n_horiz : ihoriz - 1
+                infront_idx = ihoriz == n_horiz ? 1       : ihoriz + 1
+            else
+                behind_idx  = ihoriz - 1
+                infront_idx = ihoriz + 1
+            end
+            for ialt in 1:GV.n_all_layers
+                diff_back = 0.0
+                diff_front = 0.0
+
+                if GV.enable_horiz_transport
+                    if behind_idx >= 1
+                        K_back = (K[ihoriz][ialt] + K[behind_idx][ialt]) / 2
+                        D_back = (D[s][ihoriz][ialt] + D[s][behind_idx][ialt]) / 2
+                        diff_back = (K_back + D_back) / GV.dx^2
+                    end
+
+                    if infront_idx <= n_horiz
+                        K_front = (K[ihoriz][ialt] + K[infront_idx][ialt]) / 2
+                        D_front = (D[s][ihoriz][ialt] + D[s][infront_idx][ialt]) / 2
+                        diff_front = (K_front + D_front) / GV.dx^2
+                    end
+                end
+
+                # v = horiz_wind_v[ihoriz][ialt]
+                # adv_front = v > 0 ? v / GV.dx : 0.0
+                # adv_back  = v < 0 ? -v / GV.dx : 0.0
+
+                v_local = horiz_wind_v[ihoriz][ialt]
+                v_front = infront_idx <= n_horiz ? horiz_wind_v[infront_idx][ialt] : 0.0
+                v_back  = behind_idx >= 1     ? horiz_wind_v[behind_idx][ialt]  : 0.0
+
+                adv_front = 0.0
+                adv_back  = 0.0
+                if GV.enable_horiz_transport
+                    adv_front = (v_local > 0 ? v_local : 0.0) / GV.dx +
+                                (v_front < 0 ? -v_front : 0.0) / GV.dx
+                    adv_back  = (v_local < 0 ? -v_local : 0.0) / GV.dx +
+                                (v_back  > 0 ? v_back  : 0.0) / GV.dx
+                end
+
+                fluxcoef_dict[s][ihoriz][ialt, 1] = diff_back + adv_back
+                fluxcoef_dict[s][ihoriz][ialt, 2] = diff_front + adv_front
+            end
+        end
+    end
+
+    # if !GV.enable_horiz_transport && all(all(v .== 0.0) for v in horiz_wind_v)
+    #     maxval = maximum(abs, vcat([vec(mat) for col in values(fluxcoef_dict) for mat in col]...))
+    #     println("DEBUG: horiz transport disabled, max coefficient = ", maxval)
+    # end
+
+    # return fluxcoef_dict_horiz
+    return fluxcoef_dict
+end
+
+function Keddy(z::Vector, nt; ihoriz=nothing, globvars...)
     #=
     Input:
         z: Altitude in cm
-        nt: Total atmospheric density
-    Ouptut:
+        nt: Total atmospheric density.
+            - For single-column case: Vector (#/cm³)
+            - For multi-column, this should be a Matrix (#altitudes, n_horiz), and `ihoriz` must be specified.
+    Output:
         k: eddy diffusion coefficients at all altitudes.
            Units: cm^2/s
+
+    If running multi-column, make sure to specify the column index (ihoriz).
+    This version accommodates both single-column and multi-column simulations.
     =#
 
     GV = values(globvars)
     required = [:planet]
     check_requirements(keys(GV), required)
 
-    k = zeros(size(z)) # Initialize array for eddy diffusion
-    if GV.planet=="Mars"
-        upperatm = findall(i->i .> 60e5, z)
-        k[findall(i->i .<= 60e5, z)] .= 10. ^ 6
-        k[upperatm] .= 2e13 ./ sqrt.(nt[upperatm])
-    elseif GV.planet=="Venus"
-        k = 8e12*(nt .^ -0.5)
+    k = zeros(size(z))
+
+    if GV.planet == "Mars"
+        upperatm = findall(z .> 60e5)
+
+        # Assign constant Keddy below 60 km altitude (lower atmosphere)
+        k[z .<= 60e5] .= 1e6
+
+        # Upper atmosphere (>60 km), altitude-dependent Keddy
+        if ndims(nt) == 1  # Single-column case
+            k[upperatm] .= 2e13 ./ sqrt.(nt[upperatm])
+        elseif ndims(nt) == 2  # Multi-column case
+            @assert !isnothing(ihoriz) "ihoriz must be specified for multi-column simulations."
+            k[upperatm] .= 2e13 ./ sqrt.(nt[ihoriz, upperatm])
+        else
+            throw("Invalid dimensions for nt. Expecting Vector or Matrix.")
+        end
+
+    elseif GV.planet == "Venus"
+        # Venus: just an altitude-dependent eddy diffusion
+        if ndims(nt) == 1  # Single-column case
+            k .= 8e12 .* (nt .^ -0.5)
+        else  # Multi-column case
+            k .= 8e12 .* (nt[ihoriz, :] .^ -0.5)
+        end
     end
 
     return k
@@ -1967,41 +2405,240 @@ thermaldiff(sp) = get(Dict(:H=>-0.25, :H2=>-0.25, :D=>-0.25, :HD=>-0.25,
                                 :Hpl=>-0.25, :H2pl=>-0.25, :Dpl=>-0.25, :HDpl=>-0.25,
                                 :Hepl=>-0.25), sp, 0)
 
-function update_diffusion_and_scaleH(species_list, atmdict::Dict{Symbol, Vector{ftype_ncur}}, D_coefs; globvars...) 
+function update_diffusion_and_scaleH(
+    species_list,
+    atmdict::Dict{Symbol, Vector{Array{ftype_ncur}}}, 
+    n_horiz::Int64;
+    globvars...
+) 
+    #=
+    Calculates:
+        1) The eddy diffusion coefficient K for each column;
+        2) The mean scale height H₀ for each column (both neutral and ion);
+        3) The molecular (or ambipolar) diffusion coefficients, stored in Dcoef_dict.
+
+    Inputs:
+        - atmdict: Atmospheric state dictionary with boundary layers already included
+        - n_horiz: Number of vertical columns
+        - species_list: The species for which to generate molecular or ambipolar D.
+
+    Outputs:
+        - K: Vector of length n_horiz, each entry is a 1D array of K vs altitude
+        - H0_dict: Dict("neutral"=>[H0_neutral_col1, H0_neutral_col2, ...],
+                        "ion"=>[H0_ion_col1, H0_ion_col2, ...])
+        - Dcoef_dict: Dict(s1 => [[D alt array col1], [D alt array col2], ...],
+                            s2 => [...], ...)
+    =#
+    GV = values(globvars)
+    required = [
+        :all_species, :alt, :speciesbclist, :M_P, :molmass, :neutral_species,
+        :n_alt_index, :polarizability, :planet, :R_P, :q, :Tn, :Tp,
+        :Tprof_for_diffusion, :use_ambipolar, :use_molec_diff
+    ]
+    check_requirements(keys(GV), required)
+
+    # Assumes atmdict already includes boundary layers
+    ncur_with_bdys = ncur_with_boundary_layers(
+        atmdict, n_horiz; GV.n_alt_index, GV.all_species
+    )
+    num_alts_with_bdy = length(ncur_with_bdys[GV.all_species[1]][1])
+
+    # 1) Eddy diffusion, explicitly calculated for each column
+    K = [
+        Keddy(
+            GV.alt,
+            n_tot(ncur_with_bdys, ihoriz; GV.all_species, GV.n_alt_index);
+            ihoriz = ihoriz,
+            globvars...
+        )
+        for ihoriz in 1:n_horiz
+    ]
+
+    # 2) Mean atmospheric scale heights (neutral and ion), column-wise explicitly
+    H0_dict = Dict{String, Vector{Vector{ftype_ncur}}}()
+    H0_dict["neutral"] = [
+        scaleH(ncur_with_bdys, GV.Tn[ihoriz, :], n_horiz, ihoriz; globvars...)
+        for ihoriz in 1:n_horiz
+    ]
+    H0_dict["ion"] = [
+        scaleH(ncur_with_bdys, GV.Tp[ihoriz, :], n_horiz, ihoriz; globvars...)
+        for ihoriz in 1:n_horiz
+    ]
+
+    # 3) Molecular/Ambipolar diffusion, explicitly calculated per species per column
+    Dcoef_dict = Dict{Symbol, Vector{Vector{ftype_ncur}}}()
+
+    for s in species_list
+        # Freshly initialized array per species and column (no reuse)
+        D_coefs_for_s = [
+            zeros(ftype_ncur, num_alts_with_bdy) for _ in 1:n_horiz
+        ]
+
+        # Calculate diffusion coefficient for this species
+        Dcoef!(D_coefs_for_s,
+               GV.Tprof_for_diffusion[charge_type(s)],  # (num_alts_with_bdy, n_horiz)
+               s,
+               ncur_with_bdys,
+               n_horiz;
+               globvars...
+        )
+
+        # Store the calculated coefficients
+        Dcoef_dict[s] = deepcopy(D_coefs_for_s)
+    end
+
+    # ------------------------------------------------------------------
+    # Validate shapes
+    # ------------------------------------------------------------------
+    expected_alt_len = GV.n_all_layers
+    @assert length(K) == n_horiz
+    @assert all(length(k) == expected_alt_len for k in K)
+    @assert all(length(h) == expected_alt_len for h in H0_dict["neutral"])
+    @assert all(length(h) == expected_alt_len for h in H0_dict["ion"])
+    for s in species_list
+        @assert length(Dcoef_dict[s]) == n_horiz
+        @assert all(length(vec) == expected_alt_len for vec in Dcoef_dict[s])
+    end
+
+    return K, H0_dict, Dcoef_dict
+end
+
+function update_transport_coefficients(
+    species_list,
+    atmdict::Dict{Symbol, Vector{Array{Float64}}},
+    D_coefs::Vector{Matrix{Float64}},  # Unused
+    M::Matrix{Float64},  # now explicitly 2D: num_layers × n_horiz
+    n_horiz::Int;
+    calc_nonthermal=true,
+    debug=true,
+    globvars...
+)
+    # Call the real function that doesn't expect D_coefs
+    return update_transport_coefficients(
+        species_list,
+        atmdict,
+        M,
+        n_horiz;
+        calc_nonthermal=calc_nonthermal,
+        debug=debug,
+        globvars...
+    )
+end
+
+function update_transport_coefficients(
+    species_list,
+    atmdict::Dict{Symbol, Vector{Array{ftype_ncur}}},
+    M::Matrix{ftype_ncur},  # now explicitly 2D: num_layers × n_horiz
+    n_horiz::Int64;
+    calc_nonthermal=true,
+    debug=true,
+    globvars...
+)
     #=
     Input:
-        atmdict: Atmospheric state dictionary without boundary layers
-        Tn: Neutral temperature profile
-        Tp: Plasma temperature profile
-        D_coefs: placeholder array for diffusion coefficients to speed up performance.
-        bcdict: boundary condition dictionary
-        species_list: Species for which to generate molecular diffusion coefficients. This allows the code to only do it for
-                 transport species during the main simulation run, and for all species when trying to plot 
-                 rate balances after the run.
+      - species_list: Species that need transport coefficients updated
+      - atmdict: Current atmospheric state dictionary (WITH boundary layers) 
+      - M: total atmospheric density by altitude and horizontal column (num_layers × n_horiz)
+      - n_horiz: Number of columns
+      - calc_nonthermal: whether to compute nonthermal BCs (like H, D escape)
     Output:
-        K: Vector of eddy diffusion coefficient by altitude. Independent of species.
-        Dcoefs: Dictionary of molecular diffusion by altitude. Keys are species: species=>[D by altitude] 
-        H0: Dictionary of mean atmospheric scale height by altitude. Keys are "neutral" and "ion". 
+      - tlower, tup, tdown, tupper: boundary & in‐domain transport coefficients
     =#
     GV = values(globvars)
-    required = [:all_species, :alt, :speciesbclist, :M_P, :molmass, :neutral_species, :n_alt_index, :polarizability, :planet, :R_P, :q,
-               :Tn, :Tp, :Tprof_for_diffusion, :use_ambipolar, :use_molec_diff]
+    required = [
+        :all_species, :alt, :speciesbclist, :dz, :hot_H_network, :hot_H_rc_funcs, 
+        :hot_D_network, :hot_D_rc_funcs, :hot_H2_network, :hot_H2_rc_funcs,
+        :hot_HD_network, :hot_HD_rc_funcs, :Hs_dict, :ion_species, :M_P, :molmass,
+        :neutral_species, :non_bdy_layers, :num_layers, :n_all_layers, :n_alt_index,
+        :polarizability, :q, :R_P, :Tn, :Ti, :Te, :Tp, :Tprof_for_diffusion,
+        :transport_species, :use_ambipolar, :use_molec_diff, :zmax
+    ]
     check_requirements(keys(GV), required)
 
-    ncur_with_bdys = ncur_with_boundary_layers(atmdict; GV.n_alt_index, GV.all_species)
-    
-    K = Keddy(GV.alt, n_tot(ncur_with_bdys; GV.all_species, GV.n_alt_index); GV.planet)
-    H0_dict = Dict{String, Vector{ftype_ncur}}("neutral"=>scaleH(ncur_with_bdys, GV.Tn; globvars...),
-                                               "ion"=>scaleH(ncur_with_bdys, GV.Tp; globvars...))
-    
-    # Molecular diffusion is only needed for transport species, though.  
-    Dcoef_dict = Dict{Symbol, Vector{ftype_ncur}}([s=>deepcopy(Dcoef!(D_coefs, GV.Tprof_for_diffusion[charge_type(s)], s, ncur_with_bdys; globvars...)) for s in species_list])
+    # 1) Build the K, H0, and Dcoef_dict
+    K_eddy_arr, H0_dict, Dcoef_dict = update_diffusion_and_scaleH(
+        species_list, atmdict, n_horiz; globvars...
+    )
+    # K_eddy_arr is a Vector of length n_horiz; each is 1D array of K vs altitude
+    # H0_dict = Dict("neutral" => [...], "ion"=>[...]) each an array of length n_horiz
+    # Dcoef_dict[s] = [[D vs alt col1], [D vs alt col2], ...]
+
+    # 2) Build the flux coefficients dictionary
+    fluxcoefs_all = fluxcoefs(
+        species_list,
+        K_eddy_arr,
+        Dcoef_dict,
+        H0_dict,
+        n_horiz; 
+        globvars...
+    )
+    # fluxcoefs_all[s][ihoriz] is a 2D array (num_alt x 2) => e.g. [down, up] at each altitude
+
+    # Prepare arrays to store upward/downward transport in the bulk layers
+    # shape = (n_horiz, num_layers, number_of_transport_species)
+    tup   = fill(-999., n_horiz, GV.num_layers, length(GV.transport_species))
+    tdown = fill(-999., n_horiz, GV.num_layers, length(GV.transport_species))
+
+    # Fill those from fluxcoefs
+    for (isp, s) in enumerate(GV.transport_species)
+        for ihoriz in 1:n_horiz
+            # The inner bulk layers are alt indices 2:end-1 in fluxcoefs
+            # with columns: col=1 => downward, col=2 => upward
+            # We skip boundary layers => fluxcoefs_all[s][ihoriz][2:end-1, 1 or 2]
+            tup[ihoriz, :, isp]   .= fluxcoefs_all[s][ihoriz][2:end-1, 2]
+            tdown[ihoriz, :, isp] .= fluxcoefs_all[s][ihoriz][2:end-1, 1]
+        end
+    end
 
-    return K, H0_dict, Dcoef_dict
+    # 3) Boundary conditions
+    bc_dict = boundaryconditions(
+        fluxcoefs_all,
+        atmdict,
+        M,
+        n_horiz;
+        nonthermal=calc_nonthermal,
+        globvars...
+    )
+    # bc_dict[s][ihoriz][1, :] => lower boundary [density-dependent, density-indep]
+    # bc_dict[s][ihoriz][2, :] => upper boundary
+
+    # Convert bc_dict to tlower and tupper shape
+    tlower = Vector{Array{Float64}}(undef, n_horiz)
+    tupper = Vector{Array{Float64}}(undef, n_horiz)
+    for ihoriz in 1:n_horiz
+        # Each is shape (2, number_of_transport_species)
+        # so we gather bc_dict[sp][ihoriz][1,:] for each sp in transport_species
+        tlower[ihoriz] = permutedims(reduce(hcat, [
+            bc_dict[sp][ihoriz][1, :] for sp in GV.transport_species
+        ]))
+        tupper[ihoriz] = permutedims(reduce(hcat, [
+            bc_dict[sp][ihoriz][2, :] for sp in GV.transport_species
+        ]))
+    end
+
+    if debug
+        println("[update_transport_coefficients] vertical transport coefficients:")
+        nprint = min(3, GV.num_layers)
+        for ih in 1:n_horiz
+            println("  column ", ih, " tup[1:" , nprint, "] = ",
+                    tup[ih, 1:nprint, :])
+            println("  column ", ih, " tdown[1:" , nprint, "] = ",
+                    tdown[ih, 1:nprint, :])
+        end
+        if !GV.enable_horiz_transport && n_horiz > 1
+            identical = all(
+                arrays_equal_with_nan(tup[ih, :, :], tup[1, :, :]) &&
+                arrays_equal_with_nan(tdown[ih, :, :], tdown[1, :, :])
+                for ih in 2:n_horiz)
+            println("  identical across columns? ", identical)
+        end
+    end
+
+    return tlower, tup, tdown, tupper
 end
 
-function update_transport_coefficients(species_list, atmdict::Dict{Symbol, Vector{ftype_ncur}}, D_coefs, M; 
-                                       calc_nonthermal=true, globvars...) 
+function update_horiz_transport_coefficients(species_list, atmdict::Dict{Symbol, Vector{Array{ftype_ncur}}}, D_coefs, M, n_horiz::Int64;
+                                       calc_nonthermal=true, cyclic=true, debug=true, globvars...)
     #=
     Input:
         species_list: Species which will have transport coefficients updated
@@ -2013,43 +2650,109 @@ function update_transport_coefficients(species_list, atmdict::Dict{Symbol, Vecto
         species_list: Species for which to generate molecular diffusion coefficients. This allows the code to only do it for
                  transport species during the main simulation run, and for all species when trying to plot 
                  rate balances after the run.
+        cyclic: wrap the horizontal domain so that material leaving one edge
+                enters from the opposite side
 
     Return: 
-        Transport coefficients for all atmospheric layers, units 1/s
+        Horizontal transport coefficients for all atmospheric layers, units 1/s
 
-        tlower: transport coefficients at the lower boundary layer. shape: # TODO
-        tup: upward coefficients at inner bulk layers. shape: #TODO 
-        tdown: downward coefficients at inner bulk layers. shape: #TODO 
-        tupper: at the upper boundary layer. shape: #TODO 
+        tbackedge: horizontal transport coefficients at the back edge. shape: a vector of GV.num_layers arrays of size (2 x length(GV.transport_species))
+        tforwards: forward-moving (lower to higher vertical column number) coefficients for all columns. shape: length(GV.transport_species) * GV.num_layers
+        tbackwards: backward-moving (higher to lower vertical column number) coefficients for all columns. shape: length(GV.transport_species) * GV.num_layers
+        tfrontedge: horizontal transport coefficients at the front edge. shape: a vector of GV.num_layers arrays of size (2 x GV.transport_species)
     =#
 
     GV = values(globvars)
-    required = [:all_species, :alt, :speciesbclist, :dz, :hot_H_network, :hot_H_rc_funcs, :hot_D_network, :hot_D_rc_funcs, 
-               :hot_H2_network, :hot_H2_rc_funcs, :hot_HD_network, :hot_HD_rc_funcs, :Hs_dict, 
-               :ion_species, :M_P, :molmass, :neutral_species, :non_bdy_layers, :num_layers, :n_all_layers, :n_alt_index, 
-               :polarizability, :q, :R_P, :Tn, :Ti, :Te, :Tp, :Tprof_for_diffusion, :transport_species, :use_ambipolar, :use_molec_diff, :zmax]
+    required = [:all_species, :alt, :speciesbclist, :dx, :hot_H_network, :hot_H_rc_funcs, :hot_D_network, :hot_D_rc_funcs,
+               :hot_H2_network, :hot_H2_rc_funcs, :hot_HD_network, :hot_HD_rc_funcs, :Hs_dict,
+               :ion_species, :M_P, :molmass, :neutral_species, :non_bdy_layers, :num_layers, :n_all_layers, :n_alt_index,
+               :polarizability, :q, :R_P, :Tn, :Ti, :Te, :Tp, :Tprof_for_diffusion, :transport_species,
+               :use_ambipolar, :use_molec_diff, :zmax, :horiz_wind_v, :enable_horiz_transport]
     check_requirements(keys(GV), required)
-    
-    # Update the diffusion coefficients and scale heights
-    K_eddy_arr, H0_dict, Dcoef_dict = update_diffusion_and_scaleH(species_list, atmdict, D_coefs; globvars...)
 
     # Get flux coefficients
-    fluxcoefs_all = fluxcoefs(species_list, K_eddy_arr, Dcoef_dict, H0_dict; globvars...)
-    
-    # Transport coefficients, non-boundary layers
-    tup = fill(-999., length(GV.transport_species), GV.num_layers)
-    tdown = fill(-999., length(GV.transport_species), GV.num_layers)
-    for (i, s) in enumerate(GV.transport_species)
-        tup[i, :] .= fluxcoefs_all[s][2:end-1, 2]
-        tdown[i, :] .= fluxcoefs_all[s][2:end-1, 1]
+    # Calculate diffusion coefficients and scale heights
+    K_eddy_arr, H0_dict, Dcoef_dict = update_diffusion_and_scaleH(
+        species_list,
+        atmdict,
+        n_horiz;
+        globvars...
+    )
+
+    # Get horizontal flux coefficients
+    fluxcoefs_horiz_all = fluxcoefs_horiz(
+        species_list,
+        K_eddy_arr,
+        Dcoef_dict,
+        GV.horiz_wind_v,
+        n_horiz;
+        cyclic=cyclic,
+        globvars...
+    )
+
+    tforwards  = fill(0.0, n_horiz, GV.num_layers, length(species_list))
+    tbackwards = fill(0.0, n_horiz, GV.num_layers, length(species_list))
+
+    for (isp, sp) in enumerate(species_list)
+        for ihoriz in 1:n_horiz
+            tbackwards[ihoriz, :, isp] .= fluxcoefs_horiz_all[sp][ihoriz][2:end-1, 1]
+            tforwards[ihoriz, :, isp]  .= fluxcoefs_horiz_all[sp][ihoriz][2:end-1, 2]
+        end
+    end
+
+    # Validate horizontal coefficient shapes
+    expected_flux_shape = (GV.n_all_layers, 2)
+    @assert all(all(size(mat) == expected_flux_shape for mat in mats)
+                for mats in values(fluxcoefs_horiz_all))
+    expected_tb_shape = (n_horiz, GV.num_layers, length(species_list))
+    @assert size(tforwards) == expected_tb_shape
+    @assert size(tbackwards) == expected_tb_shape
+
+    bc_dict_horiz = boundaryconditions_horiz(atmdict, GV.horiz_wind_v, n_horiz; cyclic=cyclic, globvars...)
+
+    # transport coefficients for boundaries
+    tbackedge = Vector{Array{Float64}}(undef, GV.num_layers)
+    tfrontedge = Vector{Array{Float64}}(undef, GV.num_layers)
+    for ialt in 1:GV.num_layers
+        back_cols  = [bc_dict_horiz[sp][ialt][1, :] for sp in GV.transport_species]
+        front_cols = [bc_dict_horiz[sp][ialt][2, :] for sp in GV.transport_species]
+        tbackedge[ialt]  = permutedims(reduce(hcat, back_cols))
+        tfrontedge[ialt] = permutedims(reduce(hcat, front_cols))
     end
-    bc_dict = boundaryconditions(fluxcoefs_all, atmdict, M; nonthermal=calc_nonthermal, globvars...)
 
-    # transport coefficients for boundary layers
-    tlower = permutedims(reduce(hcat, [bc_dict[sp][1,:] for sp in GV.transport_species]))
-    tupper = permutedims(reduce(hcat, [bc_dict[sp][2,:] for sp in GV.transport_species]))
+    expected_edge_shape = (length(GV.transport_species), 2)
+    @assert all(size(mat) == expected_edge_shape for mat in tbackedge) "horizontal back edge shape mismatch"
+    @assert all(size(mat) == expected_edge_shape for mat in tfrontedge) "horizontal front edge shape mismatch"
+
+    # if !GV.enable_horiz_transport && all(all(v .== 0.0) for v in GV.horiz_wind_v)
+    #     max_for  = maximum(abs, tforwards)
+    #     max_back = maximum(abs, tbackwards)
+    #     max_backedge = maximum(abs, vcat([vec(m) for m in tbackedge]...))
+    #     max_frontedge = maximum(abs, vcat([vec(m) for m in tfrontedge]...))
+    #     println("DEBUG: horiz transport disabled -- max forward=", max_for,
+    #             " max backward=", max_back,
+    #             " back edge=", max_backedge,
+    #             " front edge=", max_frontedge)
+    # end    
+
+    if debug
+        println("[update_horiz_transport_coefficients] horizontal transport coefficients:")
+        nprint = min(3, GV.num_layers)
+        for ih in 1:n_horiz
+            println("  column ", ih, " forwards[1:" , nprint, "] = ",
+                    tforwards[ih, 1:nprint, :])
+            println("  column ", ih, " backwards[1:" , nprint, "] = ",
+                    tbackwards[ih, 1:nprint, :])
+        end
+        if !GV.enable_horiz_transport
+            max_for  = maximum(abs, tforwards)
+            max_back = maximum(abs, tbackwards)
+            println("  horizontal disabled -> max forward=", max_for,
+                    " max backward=", max_back)
+        end
+    end
 
-    return tlower, tup, tdown, tupper
+    return tbackedge, tforwards, tbackwards, tfrontedge
 end
 
 #===============================================================================#
@@ -2111,7 +2814,8 @@ Psat(T) = (1e-6 ./ (kB_MKS .* T)) .* (10 .^ (-2663.5 ./ T .+ 12.537))
 # However, this function is defined on the offchance someone studies HDO.
 Psat_HDO(T) = (1e-6/(kB_MKS * T))*(10^(-2663.5/T + 12.537))
 
-function set_h2oinitfrac_bySVP(atmdict, h_alt; globvars...)
+# function set_h2oinitfrac_bySVP(atmdict, h_alt; globvars...)
+function set_h2oinitfrac_bySVP(atmdict, h_alt; ihoriz=1, globvars...)
     #=
     Calculates the initial fraction of H2O in the atmosphere, based on the supplied mixing ratio (global variable)
     and the saturation vapor pressure of water.
@@ -2127,8 +2831,7 @@ function set_h2oinitfrac_bySVP(atmdict, h_alt; globvars...)
                :H2Osat, :water_mixing_ratio]
     check_requirements(keys(GV), required)
 
-    H2Osatfrac = GV.H2Osat ./ map(z->n_tot(atmdict, z; GV.all_species, GV.n_alt_index), GV.alt)  # get SVP as fraction of total atmo
-
+    H2Osatfrac = GV.H2Osat ./ map(z->n_tot(atmdict, z, ihoriz; GV.all_species, GV.n_alt_index), GV.alt)  # get SVP as fraction of total atmo for this column
     # set H2O SVP fraction to minimum for all alts above first time min is reached
     H2Oinitfrac = H2Osatfrac[1:something(findfirst(isequal(minimum(H2Osatfrac)), H2Osatfrac), 0)]
     H2Oinitfrac = [H2Oinitfrac;   # ensures no supersaturation
@@ -2161,12 +2864,20 @@ function setup_water_profile!(atmdict; constfrac=1, dust_storm_on=false, make_sa
     =#
 
     GV = values(globvars)
-    check_requirements(keys(GV), [:all_species, :DH, :n_alt_index, :planet, :plot_grid, :results_dir, :sim_folder_name])
+    check_requirements(keys(GV), [:all_species, :DH, :n_alt_index, :n_horiz, :planet, :plot_grid, :results_dir, :sim_folder_name, :enable_horiz_transport])
 
     # Set the initial fraction of the atmosphere for water to take up, plus the saturation fraction
     # ================================================================================================================
     # Currently this doesn't change behavior based on planet. 5/15/24
-    H2Oinitfrac, H2Osatfrac = set_h2oinitfrac_bySVP(atmdict, hygropause_alt; globvars...)
+    # H2Oinitfrac, H2Osatfrac = set_h2oinitfrac_bySVP(atmdict, hygropause_alt; globvars...)
+
+    H2Oinitfrac_all = Vector{Vector{ftype_ncur}}(undef, GV.n_horiz)
+    H2Osatfrac_all = Vector{Vector{ftype_ncur}}(undef, GV.n_horiz)
+
+    for ihoriz in 1:GV.n_horiz
+        H2Oinitfrac_all[ihoriz], H2Osatfrac_all[ihoriz] =
+            set_h2oinitfrac_bySVP(atmdict, hygropause_alt; ihoriz=ihoriz, globvars...)
+    end
 
     if GV.planet=="Mars"
         required = [:alt, :H2Osat, :n_alt_index, :non_bdy_layers, :num_layers, :speciescolor, :speciesstyle, :upper_lower_bdy_i, :water_mixing_ratio,]
@@ -2182,57 +2893,92 @@ function setup_water_profile!(atmdict; constfrac=1, dust_storm_on=false, make_sa
             toplim_dict = Dict("mesosphere"=>GV.upper_lower_bdy_i, "everywhere"=>GV.n_alt_index[GV.alt[end]])
             a = 1
             b = toplim_dict[excess_water_in]
-            H2Oinitfrac[a:b] = H2Oinitfrac[a:b] .* water_tanh_prof(GV.non_bdy_layers./1e5; z0=GV.ealt, f=GV.ffac)[a:b]
+            # H2Oinitfrac[a:b] = H2Oinitfrac[a:b] .* water_tanh_prof(GV.non_bdy_layers./1e5; z0=GV.ealt, f=GV.ffac)[a:b]
+            for ihoriz in 1:GV.n_horiz
+                prof = H2Oinitfrac_all[ihoriz]
+                prof[a:b] .= prof[a:b] .* water_tanh_prof(GV.non_bdy_layers./1e5; z0=GV.ealt, f=GV.ffac)[a:b]
+                H2Oinitfrac_all[ihoriz] = prof
+            end
 
             # Set the upper atmo to be a constant mixing ratio, wherever the disturbance ends
             if excess_water_in=="everywhere"
-                H2Oinitfrac[GV.upper_lower_bdy_i:end] .= H2Oinitfrac[GV.upper_lower_bdy_i]
+                # H2Oinitfrac[GV.upper_lower_bdy_i:end] .= H2Oinitfrac[GV.upper_lower_bdy_i]
+                for ihoriz in 1:GV.n_horiz
+                    prof = H2Oinitfrac_all[ihoriz]
+                    prof[GV.upper_lower_bdy_i:end] .= prof[GV.upper_lower_bdy_i]
+                    H2Oinitfrac_all[ihoriz] = prof
+                end
             end
         end
 
         # set the water profiles 
         # ===========================================================================================================
-        atmdict[:H2O] = H2Oinitfrac.*n_tot(atmdict; GV.n_alt_index, GV.all_species)
-        atmdict[:HDO] = 2 * GV.DH * atmdict[:H2O] 
-        HDOinitfrac = atmdict[:HDO] ./ n_tot(atmdict; GV.n_alt_index, GV.all_species)  # Needed to make water plots.
+        for ihoriz in 1:GV.n_horiz
+            atmdict[:H2O][ihoriz] = H2Oinitfrac_all[ihoriz] .* n_tot(atmdict, ihoriz; GV.n_alt_index, GV.all_species)
+            atmdict[:HDO][ihoriz] = 2 * GV.DH * atmdict[:H2O][ihoriz]
+        end
+        HDOinitfrac_all = [atmdict[:HDO][ihoriz] ./ n_tot(atmdict, ihoriz; GV.n_alt_index, GV.all_species)
+                            for ihoriz in 1:GV.n_horiz]
 
         # Add a gaussian parcel of water, to simulate the effect of a dust storm
         # ===========================================================================================================
         if dust_storm_on
             sigma = 12.5
-            H2Oppm = 1e-6*map(z->GV.H2O_excess .* exp(-((z-GV.ealt)/sigma)^2), GV.non_bdy_layers/1e5) + H2Oinitfrac 
-            HDOppm = 1e-6*map(z->GV.HDO_excess .* exp(-((z-GV.ealt)/sigma)^2), GV.non_bdy_layers/1e5) + HDOinitfrac
-            atmdict[:H2O][1:GV.upper_lower_bdy_i] = (H2Oppm .* n_tot(atmdict; GV.n_alt_index, GV.all_species))[1:GV.upper_lower_bdy_i]
-            atmdict[:HDO][1:GV.upper_lower_bdy_i] = (HDOppm .* n_tot(atmdict; GV.all_species))[1:GV.upper_lower_bdy_i]
+            for ihoriz in 1:GV.n_horiz
+                H2Oppm = 1e-6*map(z->GV.H2O_excess .* exp(-((z-GV.ealt)/sigma)^2), GV.non_bdy_layers/1e5) + H2Oinitfrac_all[ihoriz]
+                HDOppm = 1e-6*map(z->GV.HDO_excess .* exp(-((z-GV.ealt)/sigma)^2), GV.non_bdy_layers/1e5) + HDOinitfrac_all[ihoriz]
+                atmdict[:H2O][ihoriz][1:GV.upper_lower_bdy_i] = (H2Oppm .* n_tot(atmdict, ihoriz; GV.n_alt_index, GV.all_species))[1:GV.upper_lower_bdy_i]
+                atmdict[:HDO][ihoriz][1:GV.upper_lower_bdy_i] = (HDOppm .* n_tot(atmdict, ihoriz; GV.all_species))[1:GV.upper_lower_bdy_i]
+            end
         end
     elseif GV.planet=="Venus"
-        ntot = n_tot(atmdict; GV.n_alt_index, GV.all_species)
+        ntot_all = [n_tot(atmdict, ihoriz; GV.n_alt_index, GV.all_species) for ihoriz in 1:GV.n_horiz]
 
-        # TODO: Add a more interesting implementation as needed.
-        atmdict[:H2O] = constfrac .* ntot
-        atmdict[:HDO] = 2 * GV.DH * atmdict[:H2O] 
+        for ihoriz in 1:GV.n_horiz
+            ntot = ntot_all[ihoriz]
+            atmdict[:H2O][ihoriz] = constfrac .* ntot
+            atmdict[:HDO][ihoriz] = 2 * GV.DH * atmdict[:H2O][ihoriz]
+        end
 
         # SPECIAL: Try a prescribed high water abundance in the mesosphere.
-        if venus_special_water==true 
+        if venus_special_water == true
             n = 11
-            vmr_h2o = logrange(venus_special_h2o_bot, venus_special_h2o_top, n) 
-            vmr_hdo = logrange(venus_special_hdo_bot, venus_special_hdo_top, n) 
+            vmr_h2o = logrange(venus_special_h2o_bot, venus_special_h2o_top, n)
+            vmr_hdo = logrange(venus_special_hdo_bot, venus_special_hdo_top, n)
 
-            atmdict[:H2O][1:n] = vmr_h2o .* ntot[1:n]
-            atmdict[:HDO][1:n] = vmr_hdo .* ntot[1:n]
+            for ihoriz in 1:GV.n_horiz
+                ntot = ntot_all[ihoriz]
+                atmdict[:H2O][ihoriz][1:n] = vmr_h2o .* ntot[1:n]
+                atmdict[:HDO][ihoriz][1:n] = vmr_hdo .* ntot[1:n]
+            end
         end
     end
 
     # Plot the water profile 
     # ===========================================================================================================
     if make_sat_curve
-        satarray = H2Osatfrac
+        satarray = H2Osatfrac_all[1]
     else
         satarray = nothing 
     end
 
-    plot_water_profile(atmdict, GV.results_dir*GV.sim_folder_name; watersat=satarray, H2Oinitf=H2Oinitfrac, plot_grid=GV.plot_grid, showonly=showonly, globvars...)
-end 
+    plot_water_profile(atmdict, GV.results_dir*GV.sim_folder_name; watersat=satarray, H2Oinitf=H2Oinitfrac_all[1], plot_grid=GV.plot_grid, showonly=showonly, globvars...)
+
+    # ----------------------------------------------------------------------
+    # Consistency checks when horizontal transport is disabled
+    # ----------------------------------------------------------------------
+    if !GV.enable_horiz_transport && GV.n_horiz > 1
+        base_H2O = atmdict[:H2O][1]
+        base_HDO = atmdict[:HDO][1]
+
+        for ih in 2:GV.n_horiz
+            @assert size(atmdict[:H2O][ih]) == size(base_H2O) "H2O profile shape mismatch across columns"
+            @assert size(atmdict[:HDO][ih]) == size(base_HDO) "HDO profile shape mismatch across columns"
+            @assert all(atmdict[:H2O][ih] .== base_H2O) "H2O profiles differ across columns with horizontal transport disabled"
+            @assert all(atmdict[:HDO][ih] .== base_HDO) "HDO profiles differ across columns with horizontal transport disabled"
+        end
+    end
+end
 
 function water_tanh_prof(z; f=10, z0=62, dz=11)
     #=
@@ -2456,7 +3202,9 @@ function linear_in_species_density(sp, lossnet)
     return true 
 end
 
-function setup_photochemical_equilibrium(; globvars...)
+# function setup_photochemical_equilibrium(; globvars...)
+function setup_photochemical_equilibrium(; transportnet_horiz=[], globvars...)
+
     #=
     Output
         active_longlived_species_rates: rate expressions for species which are actively solved for.
@@ -2480,7 +3228,14 @@ function setup_photochemical_equilibrium(; globvars...)
     # transport production, transport loss, in that order.
     active_longlived_species_rates = Array{Array{Expr}}(undef, length(GV.active_longlived), 4)
     for (i, sp) in enumerate(GV.active_longlived)
-        active_longlived_species_rates[i, :] .= getrate(sp, sepvecs=true; chemnet=GV.reaction_network, GV.transportnet, GV.chem_species, GV.transport_species, )
+        # active_longlived_species_rates[i, :] .= getrate(sp, sepvecs=true; chemnet=GV.reaction_network, GV.transportnet, GV.chem_species, GV.transport_species, )
+        active_longlived_species_rates[i, :] .= getrate(sp, sepvecs=true,
+                                                       transportnet_horiz=transportnet_horiz;
+                                                       chemnet=GV.reaction_network,
+                                                       GV.transportnet,
+                                                       GV.chem_species,
+                                                       GV.transport_species, )
+
     end
 
     # ------------------ Short-lived species expression array ----------------------- #
@@ -2577,4 +3332,4 @@ function setup_photochemical_equilibrium(; globvars...)
     end
 
     return active_longlived_species_rates, short_lived_density_eqn, shortlived_density_inputs, equilibrium_eqn_terms
-end
\ No newline at end of file
+end
