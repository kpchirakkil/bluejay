diff --git a/converge_new_file.jl b/converge_new_file.jl
index 744cc6a..66bf53e 100644
--- a/converge_new_file.jl
+++ b/converge_new_file.jl
@@ -6,8 +6,8 @@
 # 
 # Eryn Cangi
 # Created 2018
-# Last edited: October 2022
-# Currently tested for Julia: 1.7.1
+# Last edited: June 2025
+# Currently tested for Julia: 1.11.2
 ###############################################################################
 
 # **************************************************************************** #
@@ -94,7 +94,7 @@ These functions are required to be in this file for one of two reasons:
    be changed so that they could be moved into the Core.jl module but I don't want to do it right now. (Feb 2023)
 =#
 
-function evolve_atmosphere(atm_init::Dict{Symbol, Array{ftype_ncur, 1}}, log_t_start, log_t_end; t_to_save=[], abstol=1e-12, reltol=1e-6, globvars...)
+function evolve_atmosphere(atm_init::Dict{Symbol, Vector{Array{ftype_ncur}}}, log_t_start, log_t_end; t_to_save=[], abstol=1e-12, reltol=1e-6, globvars...)
     #=
     Sets up the initial conditions for the simulation and calls the ODE solver. 
 
@@ -112,15 +112,15 @@ function evolve_atmosphere(atm_init::Dict{Symbol, Array{ftype_ncur, 1}}, log_t_s
     =#
     GV = values(globvars)
     @assert all(x->x in keys(GV), [:absorber, :active_species, :active_longlived, :active_shortlived, :all_species, :alt, 
-                                   :collision_xsect, :crosssection, :Dcoef_arr_template, :dt_decr_factor, :dt_incr_factor, :dz, 
+                                   :collision_xsect, :crosssection, :Dcoef_arr_template, :dt_decr_factor, :dt_incr_factor, :dz, :dx,
                                    :e_profile_type, :error_checking_scheme, :timestep_type, :H2Oi, :HDOi, 
                                    :hot_H_network, :hot_H_rc_funcs, :hot_D_network, :hot_D_rc_funcs, 
                                    :hot_H2_network, :hot_H2_rc_funcs, :hot_HD_network, :hot_HD_rc_funcs, :Hs_dict, 
                                    :inactive_species, :ion_species, :Jratelist, :logfile, :M_P, :molmass, :n_all_layers, :n_alt_index, :n_inactive, :n_steps, 
                                    :neutral_species, :non_bdy_layers, :num_layers, :plot_grid, :polarizability, :q, :R_P, :reaction_network, 
-                                   :season_length_in_sec, :sol_in_sec, :solarflux, :speciesbclist, :speciescolor, :speciesstyle, 
+                                   :season_length_in_sec, :sol_in_sec, :solarflux, :speciesbclist, :speciesbclist_horiz, :speciescolor, :speciesstyle, 
                                    :Te, :Ti, :Tn, :Tp, :Tprof_for_diffusion, :transport_species, 
-                                   :upper_lower_bdy_i, :zmax])
+                                   :upper_lower_bdy_i, :zmax, :horiz_wind_v, :enable_horiz_transport])
         
 
     println("$(Dates.format(now(), "(HH:MM:SS)")) Setting up initial state")
@@ -129,12 +129,16 @@ function evolve_atmosphere(atm_init::Dict{Symbol, Array{ftype_ncur, 1}}, log_t_s
     tspan = (10.0^log_t_start, 10.0^log_t_end)
     
     # Set up the initial state and check for any problems 
-    nstart = flatten_atm(atm_init, GV.active_longlived; GV.num_layers)
+    nstart = flatten_atm(atm_init, GV.active_longlived, n_horiz; GV.num_layers)
     find_nonfinites(nstart, collec_name="nstart")
 
     # Set up parameters
-    M = n_tot(atm_init; GV.all_species)
-    E = electron_density(atm_init; GV.e_profile_type, GV.non_bdy_layers, GV.ion_species)
+    M = zeros(GV.num_layers, n_horiz)
+    for ihoriz in 1:n_horiz
+        M[:, ihoriz] = n_tot(atm_init, ihoriz; GV.all_species)
+    end
+    E = electron_density(atm_init; GV.e_profile_type, GV.non_bdy_layers, GV.ion_species, n_horiz)
+
     params_Gear = [GV.Dcoef_arr_template, M, E]
     params_J = [globvars, GV.Dcoef_arr_template, M, E] # kwargs can't be passed to the julia ODE solver functions 
     params_exjac = deepcopy(params_Gear)  # make sure not to have a pointer problem
@@ -202,154 +206,154 @@ function evolve_atmosphere(atm_init::Dict{Symbol, Array{ftype_ncur, 1}}, log_t_s
     return sol, sim_time
 end
 
-function chemJmat(n_active_longlived, n_active_shortlived, n_inactive, Jrates, tup, tdown, tlower, tupper, M, E;
+function chemJmat(n_active_longlived, n_active_shortlived, n_inactive, Jrates, tup, tdown, tlower, tupper, tforwards, tbackwards, tfrontedge, tbackedge, M, E;
                   check_eigen=false, globvars...)
+
     #=
     Collects coordinate tuples of (I, J, V) [row index, column index, value] for a sparse matrix
     representing the chemical jacobian of the atmospheric system. 
 
     Input:
-        n_active_longlived: The atmospheric densities array, but flattened, in the form 
-                            [n_CO(z=0), n_CO2(z=0)...n_N2Dpl(z=0), n_CO(z=2)...n_N2Dpl(z=250)], for active and chemically long-lived species.
-                            I am NOT saying that CO is the first species in the order. Just describing how it goes.         
-        n_active_shortlived: active shortlived species densities, necessary to to calculations for longlived species.
-        n_inactive: A flattened array of the atmospheric densities of any inactive species, same format as nthis. Functionally constant.
-        Jrates: Flattened array of Jrates, same format as nthis.
-        tup, tdown: Transport coefficients
-        tlower, tupper: Transport coefficients
-        M: Total density by altitude for entire atmosphere
-        E: Electron profile at the present time
+        n_active_longlived: Flattened atmospheric densities for active long-lived species.
+        n_active_shortlived: Flattened atmospheric densities for active short-lived species.
+        n_inactive: Flattened atmospheric densities for inactive species.
+        Jrates: Column-specific Jrates array (species × horizontal column × altitude).
+        tup, tdown, tlower, tupper: Vertical transport coefficients.
+        tforwards, tbackwards, tfrontedge, tbackedge: Horizontal transport coefficients.
+        M: Total density by altitude for each horizontal column.
+        E: Electron density profile for each horizontal column.
     optional input:
-        check_eigen: Will check the eigenvalues of the jacobian for non-real or real/positive values if true. Not currently used
+        check_eigen: Checks eigenvalues of the jacobian if true.
     Output:
-        sparse matrix representing the chemical jacobian 
+        Sparse matrix representing the chemical jacobian.
     =#              
 
     GV = values(globvars)
     @assert all(x->x in keys(GV), [:active_longlived, :active_shortlived, :H2Oi, :HDOi, :inactive_species, :num_layers, :Tn, :Ti, :Te, :upper_lower_bdy_i])
 
-    nmat_llsp = reshape(n_active_longlived, (length(GV.active_longlived), GV.num_layers))
-    nmat_slsp = reshape(n_active_shortlived, (length(GV.active_shortlived), GV.num_layers))
-    nmat_inactive = reshape(n_inactive, (length(GV.inactive_species), GV.num_layers))
+    nmat_llsp = reshape(n_active_longlived, (length(GV.active_longlived), GV.num_layers, n_horiz))
+    nmat_slsp = reshape(n_active_shortlived, (length(GV.active_shortlived), GV.num_layers, n_horiz))
+    nmat_inactive = reshape(n_inactive, (length(GV.inactive_species), GV.num_layers, n_horiz))
     
-    # For storing the jacobian indices and values
+    # Initialize arrays for jacobian indices and values
     chemJi = Int64[]
     chemJj = Int64[]
     chemJval = ftype_chem[]
 
-    # tc___ are the coordinate tuples containing (I, J, V) to be used to fill a sparse matrix.
-    argvec = [nmat_llsp[:, 1];                        # active_longlived;
-              nmat_llsp[:, 2];                        # active_longlived_above;
-              fill(1.0, length(GV.active_longlived)); # active_longlived_below;
-              nmat_slsp[:, 1];                        # active_shortlived;
-              nmat_inactive[:,1];                     # inactive_species;
-              Jrates[:,1];                            # Jratelist;
-              GV.Tn[1]; GV.Ti[1]; GV.Te[1];           #:Tn; :Ti; :Te;
-              M[1]; E[1];                             # total density and electrons,
-              tup[:,1]; tlower[:,1];                  # local_transport_rates
-              tdown[:,2]; tlower[:,2]]
-    argvec = convert(Array{ftype_chem}, argvec)
-
-    (tclocal, tcupper, tclower) = chemJmat_local(argvec...) 
-
-    # add the influence of the local densities
-    append!(chemJi, tclocal[1])
-    append!(chemJj, tclocal[2])
-    append!(chemJval, tclocal[3])
-
-    # and the upper densities
-    append!(chemJi, tcupper[1])
-    append!(chemJj, tcupper[2] .+ length(GV.active_longlived))
-    append!(chemJval, tcupper[3])
-
-    for ialt in 2:(GV.num_layers-1)
-        argvec = [nmat_llsp[:, ialt];
-                  nmat_llsp[:, ialt+1];
-                  nmat_llsp[:, ialt-1];
-                  nmat_slsp[:, ialt];
-                  nmat_inactive[:, ialt];
-                  Jrates[:, ialt];
-                  GV.Tn[ialt]; GV.Ti[ialt]; GV.Te[ialt];
-                  M[ialt]; E[ialt];
-                  tup[:, ialt];
-                  tdown[:, ialt];
-                  tdown[:, ialt+1];
-                  tup[:, ialt-1]]
-        argvec = convert(Array{ftype_chem}, argvec)        
-
-        (tclocal, tcupper, tclower) = chemJmat_local(argvec...)
-
-        # add the influence of the local densities
-        append!(chemJi, tclocal[1].+(ialt-1)*length(GV.active_longlived))
-        append!(chemJj, tclocal[2].+(ialt-1)*length(GV.active_longlived))
-        append!(chemJval, tclocal[3])
-        # and the upper densities
-        append!(chemJi, tcupper[1].+(ialt-1)*length(GV.active_longlived))
-        append!(chemJj, tcupper[2].+(ialt  )*length(GV.active_longlived))
-        append!(chemJval, tcupper[3])
-        # and the lower densities
-        append!(chemJi, tclower[1].+(ialt-1)*length(GV.active_longlived))
-        append!(chemJj, tclower[2].+(ialt-2)*length(GV.active_longlived))
-        append!(chemJval, tclower[3])
-    end
+    # Loop over horizontal columns
+    for ihoriz in 1:n_horiz
+        for ialt in 1:GV.num_layers
+            if ialt == 1
+                # argvec = [nmat_llsp[:, ialt, ihoriz];                         
+                #           nmat_llsp[:, ialt+1, ihoriz];                      
+                #           fill(1.0, length(GV.active_longlived));           
+                #           nmat_slsp[:, ialt, ihoriz];                       
+                #           nmat_inactive[:, ialt, ihoriz];
+                argvec = [nmat_llsp[:, ialt, ihoriz];
+                          nmat_llsp[:, ialt+1, ihoriz];
+                          fill(1.0, length(GV.active_longlived));
+                          ihoriz == 1 ? fill(1.0, length(GV.active_longlived)) : nmat_llsp[:, ialt, ihoriz-1];
+                          ihoriz == n_horiz ? fill(1.0, length(GV.active_longlived)) : nmat_llsp[:, ialt, ihoriz+1];
+                          nmat_slsp[:, ialt, ihoriz];
+                          nmat_inactive[:, ialt, ihoriz];                   
+                          Jrates[:, ihoriz, ialt];                         # COLUMN-SPECIFIC Jrates
+                          GV.Tn[ihoriz, ialt]; GV.Ti[ihoriz, ialt]; GV.Te[ihoriz, ialt];
+                          M[ialt, ihoriz]; E[ihoriz][ialt];
+                          tup[ihoriz, ialt, :]; tlower[ihoriz][:,ialt];     
+                          tdown[ihoriz, ialt+1, :]; tlower[ihoriz][:,ialt+1];
+                        #   tforwards[ihoriz, ialt, :];
+                        #   ihoriz == 1 ? tbackedge[ialt][:,1] : tforwards[ihoriz-1, ialt, :];
+                        #   ihoriz == n_horiz ? tbackedge[ialt][:,2] : tbackwards[ihoriz+1, ialt, :];
+                        #   tbackwards[ihoriz, ialt, :]]
+                          ihoriz == n_horiz ? tfrontedge[ialt][:,1] : tforwards[ihoriz, ialt, :];
+                          ihoriz == 1 ? tbackedge[ialt][:,2] : tforwards[ihoriz-1, ialt, :];
+                          ihoriz == n_horiz ? tfrontedge[ialt][:,2] : tbackwards[ihoriz+1, ialt, :];
+                          ihoriz == 1 ? tbackedge[ialt][:,1] : tbackwards[ihoriz, ialt, :]]
+            elseif ialt == GV.num_layers
+                argvec = [nmat_llsp[:, ialt, ihoriz];
+                          fill(1.0, length(GV.active_longlived));
+                          nmat_llsp[:, ialt-1, ihoriz];
+                          ihoriz == 1 ? fill(1.0, length(GV.active_longlived)) : nmat_llsp[:, ialt, ihoriz-1];
+                          ihoriz == n_horiz ? fill(1.0, length(GV.active_longlived)) : nmat_llsp[:, ialt, ihoriz+1];
+                          nmat_slsp[:, ialt, ihoriz];
+                          nmat_inactive[:, ialt, ihoriz];
+                          Jrates[:, ihoriz, ialt];                         # COLUMN-SPECIFIC Jrates
+                          GV.Tn[ihoriz, ialt]; GV.Ti[ihoriz, ialt]; GV.Te[ihoriz, ialt];
+                          M[ialt, ihoriz]; E[ihoriz][ialt];
+                          tupper[ihoriz][:,1]; tdown[ihoriz, ialt, :];
+                          tupper[ihoriz][:,2]; tup[ihoriz, ialt-1, :];
+                        #   tforwards[ihoriz, ialt, :];
+                        #   ihoriz == 1 ? tbackedge[ialt][:,1] : tforwards[ihoriz-1, ialt, :];
+                        #   ihoriz == n_horiz ? tbackedge[ialt][:,2] : tbackwards[ihoriz+1, ialt, :];
+                        #   tbackwards[ihoriz, ialt, :]]
+                          ihoriz == n_horiz ? tfrontedge[ialt][:,1] : tforwards[ihoriz, ialt, :];
+                          ihoriz == 1 ? tbackedge[ialt][:,2] : tforwards[ihoriz-1, ialt, :];
+                          ihoriz == n_horiz ? tfrontedge[ialt][:,2] : tbackwards[ihoriz+1, ialt, :];
+                          ihoriz == 1 ? tbackedge[ialt][:,1] : tbackwards[ihoriz, ialt, :]]
+            else
+                argvec = [nmat_llsp[:, ialt, ihoriz];
+                          nmat_llsp[:, ialt+1, ihoriz];
+                          nmat_llsp[:, ialt-1, ihoriz];
+                          ihoriz == 1 ? fill(1.0, length(GV.active_longlived)) : nmat_llsp[:, ialt, ihoriz-1];
+                          ihoriz == n_horiz ? fill(1.0, length(GV.active_longlived)) : nmat_llsp[:, ialt, ihoriz+1];
+                          nmat_slsp[:, ialt, ihoriz];
+                          nmat_inactive[:, ialt, ihoriz];
+                          Jrates[:, ihoriz, ialt];                         # COLUMN-SPECIFIC Jrates
+                          GV.Tn[ihoriz, ialt]; GV.Ti[ihoriz, ialt]; GV.Te[ihoriz, ialt];
+                          M[ialt, ihoriz]; E[ihoriz][ialt];
+                          tup[ihoriz, ialt, :]; 
+                          tdown[ihoriz, ialt, :];
+                          tdown[ihoriz, ialt+1, :];
+                          tup[ihoriz, ialt-1, :];
+                        #   tforwards[ihoriz, ialt, :]; 
+                        #   ihoriz == 1 ? tbackedge[ialt][:,1] : tforwards[ihoriz-1, ialt, :];
+                        #   ihoriz == n_horiz ? tbackedge[ialt][:,2] : tbackwards[ihoriz+1, ialt, :];
+                        #   tbackwards[ihoriz, ialt, :]]
+                          ihoriz == n_horiz ? tfrontedge[ialt][:,1] : tforwards[ihoriz, ialt, :];
+                          ihoriz == 1 ? tbackedge[ialt][:,2] : tforwards[ihoriz-1, ialt, :];
+                          ihoriz == n_horiz ? tfrontedge[ialt][:,2] : tbackwards[ihoriz+1, ialt, :];
+                          ihoriz == 1 ? tbackedge[ialt][:,1] : tbackwards[ihoriz, ialt, :]]
+            end
+            
+            argvec = convert(Array{ftype_chem}, argvec)
+            (tclocal, tcupper, tclower, tcbehind, tcinfront) = chemJmat_local(argvec...)
+
+            # add local, upper, lower, behind, and in-front densities (as per original structure)
+            base_idx = (ihoriz-1)*(length(GV.active_longlived)*GV.num_layers) + (ialt-1)*length(GV.active_longlived)
+            append!(chemJi, base_idx .+ tclocal[1])
+            append!(chemJj, base_idx .+ tclocal[2])
+            append!(chemJval, tclocal[3])
+
+            if ialt != GV.num_layers
+                append!(chemJi, base_idx .+ tcupper[1])
+                append!(chemJj, base_idx .+ tcupper[2] .+ length(GV.active_longlived))
+                append!(chemJval, tcupper[3])
+            end
 
-    argvec = [nmat_llsp[:,end];
-              fill(1.0, length(GV.active_longlived));
-              nmat_llsp[:,end-1];
-              nmat_slsp[:, end];
-              nmat_inactive[:,end];
-              Jrates[:,end];
-              GV.Tn[end]; GV.Ti[end]; GV.Te[end];
-              M[end]; E[end]; # E FIX ATTEMPT
-              tupper[:,1]; tdown[:,end];
-              tupper[:,2]; tup[:,end-1]]
-    argvec = convert(Array{ftype_chem}, argvec)
-    
-    (tclocal, tcupper, tclower) = chemJmat_local(argvec...)
-
-    # add the influence of the local densities
-    append!(chemJi, tclocal[1].+(GV.num_layers-1)*length(GV.active_longlived))
-    append!(chemJj, tclocal[2].+(GV.num_layers-1)*length(GV.active_longlived))
-    append!(chemJval, tclocal[3])
-
-    # and the lower densities
-    append!(chemJi, tclower[1].+(GV.num_layers-1)*length(GV.active_longlived))
-    append!(chemJj, tclower[2].+(GV.num_layers-2)*length(GV.active_longlived))
-    append!(chemJval, tclower[3])
-
-    # fix water below whatever we set as upper/lower atmosphere boundary.
-    # This only runs if water is designated as an active species; if it's in inactive_species, this won't run,
-    # When it is active, this finds all the H2O and HDO indices for the lower atmosphere. 
-    # It's like above where we add (ialt-1)*length(active_species), but this way it's outside the loop.
-    if remove_rates_flag == true 
-        if planet=="Venus"
-            throw("Not supposed to delete things from water rates for Venus")
-        end
-        if in(:H2O, GV.active_longlived) && in(:HDO, GV.active_longlived)
-            H2Opositions = GV.H2Oi .+ length(GV.active_longlived)*collect(0:GV.upper_lower_bdy_i-1)
-            HDOpositions = GV.HDOi .+ length(GV.active_longlived)*collect(0:GV.upper_lower_bdy_i-1)
-            water_positions = sort(union(H2Opositions, HDOpositions))
-
-            i_remove = findall(x->in(x, water_positions), chemJi)
-            j_remove = findall(x->in(x, water_positions), chemJj) # these are removed because if a species is inert, a derivative with respect to it is a derivative of a constant 
-            remove_these = sort(union(i_remove, j_remove)) # This makes a set, since it describes the locations where the H2O and HDO indices are.
-                                                           # Kinda confusing since we're talking about indices of indices.
-            chemJval[remove_these] .= 0 
-        end
-    end 
+            if ialt != 1
+                append!(chemJi, base_idx .+ tclower[1])
+                append!(chemJj, base_idx .+ tclower[2] .- length(GV.active_longlived))
+                append!(chemJval, tclower[3])
+            end
 
-    # Uncomment the following to check the eigenvalues of the jacobian. Requires a global variable called stiffness.
-    # J = sparse(chemJi, chemJj, chemJval, length(nthis), length(nthis), +) 
-    # println("checking eigenvalues")
-    # if check_eigen==true
-    #     check_jacobian_eigenvalues(J, results_dir*sim_folder_name)
-    #     append!(stiffness, calculate_stiffness(J))
-    # end
+            if ihoriz != 1
+                append!(chemJi, base_idx .+ tcbehind[1])
+                append!(chemJj, base_idx .+ tcbehind[2] .- GV.num_layers*length(GV.active_longlived))
+                append!(chemJval, tcbehind[3])
+            end
 
+            if ihoriz != n_horiz
+                append!(chemJi, base_idx .+ tcinfront[1])
+                append!(chemJj, base_idx .+ tcinfront[2] .+ GV.num_layers*length(GV.active_longlived))
+                append!(chemJval, tcinfront[3])
+            end
+        end
+    end
+    
     return sparse(chemJi, chemJj, chemJval, length(n_active_longlived), length(n_active_longlived), +)
 end
 
-function ratefn(n_active_longlived, n_active_shortlived, n_inactive, Jrates, tup, tdown, tlower, tupper, M, E; 
+function ratefn(n_active_longlived, n_active_shortlived, n_inactive, Jrates, tup, tdown, tlower, tupper, tforwards, tbackwards, tfrontedge, tbackedge, M, E; 
                 globvars...)
     #=
     at each altitude, get the appropriate group of concentrations, coefficients, and rates to pass to ratefn_local.
@@ -360,69 +364,104 @@ function ratefn(n_active_longlived, n_active_shortlived, n_inactive, Jrates, tup
     GV = values(globvars)
     @assert all(x->x in keys(GV), [:active_longlived, :active_shortlived, :H2Oi, :HDOi, :inactive_species, :num_layers, :Tn, :Ti, :Te, :upper_lower_bdy_i])
 
-    nmat_llsp = reshape(n_active_longlived, (length(GV.active_longlived), GV.num_layers))
-    nmat_slsp = reshape(n_active_shortlived, (length(GV.active_shortlived), GV.num_layers))
-    nmat_inactive = reshape(n_inactive, (length(GV.inactive_species), GV.num_layers))
+    # Reshape vectors into matrices with species, altitudes, and columns (horizontals)
+    nmat_llsp = reshape(n_active_longlived, (length(GV.active_longlived), GV.num_layers, n_horiz))
+    nmat_slsp = reshape(n_active_shortlived, (length(GV.active_shortlived), GV.num_layers, n_horiz))
+    nmat_inactive = reshape(n_inactive, (length(GV.inactive_species), GV.num_layers, n_horiz))
+
+    # Initialize returnrates matrix
     returnrates = zeros(size(nmat_llsp))
-    
-    # fill the first altitude entry with information for all species
-    argvec = [nmat_llsp[:,1];                         # densities for active_longlived;
-              nmat_llsp[:,2];                         # active_longlived_above;
-              fill(1.0, length(GV.active_longlived)); # active_longlived_below;
-              nmat_slsp[:, 1];                        # active_shortlived;
-              nmat_inactive[:,1];                     # inactive_species;
-              Jrates[:,1];                            # Jratelist;
-              GV.Tn[1]; GV.Ti[1]; GV.Te[1];           # :Tn; :Ti; :Te;
-              M[1]; E[1];  
-              tup[:,1]; tlower[:,1]; tdown[:,2]; tlower[:,2]]
-    argvec = convert(Array{ftype_chem}, argvec)
-    
-    returnrates[:,1] .= ratefn_local(argvec...) # local_transport_rates
-
-    # iterate through other altitudes in the lower atmosphere
-    for ialt in 2:(GV.num_layers-1)
-        argvec = [nmat_llsp[:, ialt]; # active_longlived;
-                  nmat_llsp[:, ialt+1];
-                  nmat_llsp[:, ialt-1];
-                  nmat_slsp[:, ialt]; # active_shortlived;
-                  nmat_inactive[:,ialt];
-                  Jrates[:,ialt];
-                  GV.Tn[ialt]; GV.Ti[ialt]; GV.Te[ialt];
-                  M[ialt]; E[ialt]; 
-                  tup[:, ialt];
-                  tdown[:, ialt];
-                  tdown[:, ialt+1];
-                  tup[:, ialt-1]]
-        argvec = convert(Array{ftype_chem}, argvec)
-        
-        returnrates[:,ialt] .= ratefn_local(argvec...)
-    end
 
-    # fill in the last level of altitude
-    argvec = [nmat_llsp[:, end];
-              fill(1.0, length(GV.active_longlived));
-              nmat_llsp[:, end-1];
-              nmat_slsp[:, end]; # active_shortlived;
-              nmat_inactive[:,end];
-              Jrates[:,end];
-              GV.Tn[end]; GV.Ti[end]; GV.Te[end];
-              M[end]; E[end];
-              tupper[:,1];
-              tdown[:,end];
-              tupper[:,2];
-              tup[:,end-1]]
-    argvec = convert(Array{ftype_chem}, argvec)
-    returnrates[:,end] .= ratefn_local(argvec...)
-
-    # NEW: Overwrite the entries for water in the lower atmosphere with 0s so that it will behave as fixed.
-    # Only runs when water is in the active_species list. If neutrals are set to inactive, it will be taken care of already.
-    if remove_rates_flag == true # This won't run for Venus
-        if planet=="Venus"
-            throw("Not supposed to run for Venus")
+    # Loop over horizontal columns
+    for ihoriz in 1:n_horiz
+        # fill the first altitude entry with information for all species 
+        ialt = 1
+        argvec = [nmat_llsp[:, ialt, ihoriz];                      # densities for active_longlived;
+                  nmat_llsp[:, ialt+1, ihoriz];                    # active_longlived_above;
+                  fill(1.0, length(GV.active_longlived));          # active_longlived_below;
+                  ihoriz == 1 ? fill(1.0, length(GV.active_longlived)) : nmat_llsp[:, ialt, ihoriz-1];
+                  ihoriz == n_horiz ? fill(1.0, length(GV.active_longlived)) : nmat_llsp[:, ialt, ihoriz+1];
+                  nmat_slsp[:, ialt, ihoriz];                      # active_shortlived;
+                  nmat_inactive[:, ialt, ihoriz];                  # inactive_species;
+                  Jrates[:, ihoriz, ialt];                         # Jratelist (column-specific);
+                  GV.Tn[ihoriz, ialt]; GV.Ti[ihoriz, ialt]; GV.Te[ihoriz, ialt];   # :Tn; :Ti; :Te;
+                  M[ialt, ihoriz]; E[ihoriz][ialt];                # total density and electrons
+                  tup[ihoriz, ialt, :]; tlower[ihoriz][:, ialt]; tdown[ihoriz, ialt+1, :]; tlower[ihoriz][:, ialt+1]; # local transport coefficients
+                #   tforwards[ihoriz, ialt, :];
+                #   (ihoriz == 1 ? tbackedge[ialt][:,1] : tforwards[ihoriz-1, ialt, :]);
+                #   (ihoriz == n_horiz ? tbackedge[ialt][:,2] : tbackwards[ihoriz+1, ialt, :]);
+                #   tbackwards[ihoriz, ialt, :]]
+                  ihoriz == n_horiz ? tfrontedge[ialt][:,1] : tforwards[ihoriz, ialt, :];
+                  (ihoriz == 1 ? tbackedge[ialt][:,2] : tforwards[ihoriz-1, ialt, :]);
+                  (ihoriz == n_horiz ? tfrontedge[ialt][:,2] : tbackwards[ihoriz+1, ialt, :]);
+                  (ihoriz == 1 ? tbackedge[ialt][:,1] : tbackwards[ihoriz, ialt, :])]
+
+        argvec = convert(Array{ftype_chem}, argvec)
+        returnrates[:, ialt, ihoriz] .= ratefn_local(argvec...)
+
+        # iterate through other altitudes in the lower atmosphere
+        for ialt in 2:(GV.num_layers-1)
+            argvec = [nmat_llsp[:, ialt, ihoriz];
+                      nmat_llsp[:, ialt+1, ihoriz];
+                      nmat_llsp[:, ialt-1, ihoriz];
+                      ihoriz == 1 ? fill(1.0, length(GV.active_longlived)) : nmat_llsp[:, ialt, ihoriz-1];
+                      ihoriz == n_horiz ? fill(1.0, length(GV.active_longlived)) : nmat_llsp[:, ialt, ihoriz+1];
+                      nmat_slsp[:, ialt, ihoriz];
+                      nmat_inactive[:, ialt, ihoriz];
+                      Jrates[:, ihoriz, ialt];                     # Jratelist (column-specific);
+                      GV.Tn[ihoriz, ialt]; GV.Ti[ihoriz, ialt]; GV.Te[ihoriz, ialt];
+                      M[ialt, ihoriz]; E[ihoriz][ialt];
+                      tup[ihoriz, ialt, :];
+                      tdown[ihoriz, ialt, :];
+                      tdown[ihoriz, ialt+1, :];
+                      tup[ihoriz, ialt-1, :];
+                    #   tforwards[ihoriz, ialt, :];
+                    #   (ihoriz == 1 ? tbackedge[ialt][:,1] : tforwards[ihoriz-1, ialt, :]);
+                    #   (ihoriz == n_horiz ? tbackedge[ialt][:,2] : tbackwards[ihoriz+1, ialt, :]);
+                    #   tbackwards[ihoriz, ialt, :]]
+                      ihoriz == n_horiz ? tfrontedge[ialt][:,1] : tforwards[ihoriz, ialt, :];
+                      (ihoriz == 1 ? tbackedge[ialt][:,2] : tforwards[ihoriz-1, ialt, :]);
+                      (ihoriz == n_horiz ? tfrontedge[ialt][:,2] : tbackwards[ihoriz+1, ialt, :]);
+                      (ihoriz == 1 ? tbackedge[ialt][:,1] : tbackwards[ihoriz, ialt, :])]
+
+            argvec = convert(Array{ftype_chem}, argvec)
+            returnrates[:, ialt, ihoriz] .= ratefn_local(argvec...)
         end
-        if in(:H2O, GV.active_longlived) && in(:HDO, GV.active_longlived)
-            returnrates[GV.H2Oi, 1:GV.upper_lower_bdy_i] .= 0
-            returnrates[GV.HDOi, 1:GV.upper_lower_bdy_i] .= 0
+
+        # fill in the last level of altitude
+        ialt = GV.num_layers
+        argvec = [nmat_llsp[:, ialt, ihoriz];
+                  fill(1.0, length(GV.active_longlived));
+                  nmat_llsp[:, ialt-1, ihoriz];
+                  ihoriz == 1 ? fill(1.0, length(GV.active_longlived)) : nmat_llsp[:, ialt, ihoriz-1];
+                  ihoriz == n_horiz ? fill(1.0, length(GV.active_longlived)) : nmat_llsp[:, ialt, ihoriz+1];
+                  nmat_slsp[:, ialt, ihoriz];
+                  nmat_inactive[:, ialt, ihoriz];
+                  Jrates[:, ihoriz, ialt];                           # Jratelist (column-specific);
+                  GV.Tn[ihoriz, ialt]; GV.Ti[ihoriz, ialt]; GV.Te[ihoriz, ialt];
+                  M[ialt, ihoriz]; E[ihoriz][ialt];
+                  tupper[ihoriz][:,1];
+                  tdown[ihoriz, ialt, :];
+                  tupper[ihoriz][:,2];
+                  tup[ihoriz, ialt-1, :];
+                #   tforwards[ihoriz, ialt, :];
+                #   (ihoriz == 1 ? tbackedge[ialt][:,1] : tforwards[ihoriz-1, ialt, :]);
+                #   (ihoriz == n_horiz ? tbackedge[ialt][:,2] : tbackwards[ihoriz+1, ialt, :]);
+                #   tbackwards[ihoriz, ialt, :]]
+                  ihoriz == n_horiz ? tfrontedge[ialt][:,1] : tforwards[ihoriz, ialt, :];
+                  (ihoriz == 1 ? tbackedge[ialt][:,2] : tforwards[ihoriz-1, ialt, :]);
+                  (ihoriz == n_horiz ? tfrontedge[ialt][:,2] : tbackwards[ihoriz+1, ialt, :]);
+                  (ihoriz == 1 ? tbackedge[ialt][:,1] : tbackwards[ihoriz, ialt, :])]
+
+        argvec = convert(Array{ftype_chem}, argvec)
+        returnrates[:, ialt, ihoriz] .= ratefn_local(argvec...)
+
+        # Overwrite water entries if required
+        if remove_rates_flag && planet != "Venus"
+            if in(:H2O, GV.active_longlived) && in(:HDO, GV.active_longlived)
+                returnrates[GV.H2Oi, 1:GV.upper_lower_bdy_i, ihoriz] .= 0
+                returnrates[GV.HDOi, 1:GV.upper_lower_bdy_i, ihoriz] .= 0
+            end
         end
     end
 
@@ -455,9 +494,9 @@ function record_atmospheric_state(t, n, actively_solved, E_prof; opt="", globvar
     println(progress_alert)
     
     # write out the current atmospheric state to a file and plot it
-    atm_snapshot = merge(external_storage, unflatten_atm(n, actively_solved; GV.num_layers))
-    plot_atm(atm_snapshot, results_dir*sim_folder_name*"/atm_peek_$(plotnum)$(opt).png", abs_tol_for_plot, E_prof; ylims=[zmin/1e5, zmax/1e5], t="$(round(t, digits=rounding_digits))", globvars...)
-    write_atmosphere(atm_snapshot, results_dir*sim_folder_name*"/atm_state_$(lpad(plotnum,2,"0"))$(opt).h5"; t=round(t, digits=rounding_digits), globvars...)
+    atm_snapshot = merge(external_storage, unflatten_atm(n, actively_solved, n_horiz; GV.num_layers))
+    plot_atm(atm_snapshot, results_dir*sim_folder_name*"/atm_peek_$(plotnum)$(opt).png", abs_tol_for_plot, E_prof, n_horiz; ylims=[zmin/1e5, zmax/1e5], t="$(round(t, digits=rounding_digits))", globvars...)
+    write_atmosphere(atm_snapshot, results_dir*sim_folder_name*"/atm_state_$(lpad(plotnum,2,"0"))$(opt).h5", n_horiz; t=round(t, digits=rounding_digits), globvars...)
 
     # Turn this on if you'd like to take a peek at the Jrates
     # for Jspc in values(GV.neutral_species)
@@ -470,7 +509,7 @@ end
 #                                   Gear solver                                 #
 #===============================================================================#
 
-function converge(n_current::Dict{Symbol, Array{ftype_ncur, 1}}, log_t_start, log_t_end; verbose=false, t_to_save=nothing,
+function converge(n_current::Dict{Symbol, Vector{Array{ftype_ncur}}}, log_t_start, log_t_end; verbose=false, t_to_save=nothing,
                   abstol=1e-12, reltol=1e-2, globvars...)
     #= 
     Calls update! in logarithmiclly spaced timesteps until convergence, returning converged atmosphere 
@@ -485,11 +524,12 @@ function converge(n_current::Dict{Symbol, Array{ftype_ncur, 1}}, log_t_start, lo
 
     GV = values(globvars)
     @assert all(x->x in keys(GV), [:absorber, :active_species, :active_longlived, :active_shortlived, :all_species, :alt, :crosssection, 
-                                   :Dcoef_arr_template, :dt_decr_factor, :dt_incr_factor, :dz, :e_profile_type, :error_checking_scheme, 
+                                   :Dcoef_arr_template, :dt_decr_factor, :dt_incr_factor, :dz, :dx, :e_profile_type, :error_checking_scheme, 
                                    :H2Oi, :HDOi, :Hs_dict, :inactive_species, :ion_species, :Jratelist, :logfile, :molmass, 
                                    :n_all_layers, :n_alt_index, :n_inactive, :n_steps, :neutral_species, :non_bdy_layers, :num_layers, 
-                                   :plot_grid, :polarizability, :q, :reaction_network, :season_length_in_sec, :sol_in_sec, :solarflux, :speciesbclist, :speciescolor, :speciesstyle, 
-                                   :Te, :Ti, :Tn, :Tp, :timestep_type, :Tprof_for_diffusion, :upper_lower_bdy_i, :zmax])
+                                   :plot_grid, :polarizability, :q, :reaction_network, :season_length_in_sec, :sol_in_sec, :solarflux, :speciesbclist, :speciesbclist_horiz,
+                                   :speciescolor, :speciesstyle, 
+                                   :Te, :Ti, :Tn, :Tp, :timestep_type, :Tprof_for_diffusion, :upper_lower_bdy_i, :zmax, :horiz_wind_v, :enable_horiz_transport])
     
     # A combination of log timesteps when simulation time is low, and linear after - used to simulate a single season, mainly.
     if GV.timestep_type=="log-linear"
@@ -634,13 +674,14 @@ function get_rates_and_jacobian(n, p, t; globvars...)
 
     GV = values(globvars)
     @assert all(x->x in keys(GV), [:absorber, :active_species, :active_longlived, :active_shortlived, :all_species, :alt, 
-                                   :collision_xsect, :crosssection, :dz, :H2Oi, :HDOi, :Hs_dict,  
+                                   :collision_xsect, :crosssection, :dz, :dx, :H2Oi, :HDOi, :Hs_dict,  
                                    :hot_H_network, :hot_H_rc_funcs, :hot_D_network, :hot_D_rc_funcs, 
                                    :hot_H2_network, :hot_H2_rc_funcs, :hot_HD_network, :hot_HD_rc_funcs,
                                    :inactive_species, :ion_species,  :Jratelist,
                                    :molmass, :neutral_species, :non_bdy_layers, :num_layers, :n_all_layers, :n_alt_index, :n_inactive, 
-                                   :plot_grid, :polarizability, :q, :reaction_network, :solarflux, :speciesbclist, :speciescolor, :speciesstyle, :Tn, :Ti, :Te, :Tp, :Tprof_for_diffusion, 
-                                   :transport_species, :upper_lower_bdy_i, :zmax])
+                                   :plot_grid, :polarizability, :q, :reaction_network, :solarflux, :speciesbclist, :speciesbclist_horiz, :speciescolor, :speciesstyle,
+                                   :Tn, :Ti, :Te, :Tp, :Tprof_for_diffusion, :transport_species, :upper_lower_bdy_i, :zmax, :horiz_wind_v, :enable_horiz_transport])
+
     # Unpack the parameters ---------------------------------------------------------------
     D_arr, M, E = p 
 
@@ -658,35 +699,41 @@ function get_rates_and_jacobian(n, p, t; globvars...)
     end
 
     # retrieve the shortlived species from their storage and flatten them
-    n_short = flatten_atm(external_storage, GV.active_shortlived; GV.num_layers)
+    n_short = flatten_atm(external_storage, GV.active_shortlived, n_horiz; GV.num_layers)
 
     # Update Jrates
-    n_cur_all = compile_ncur_all(n, n_short, GV.n_inactive; GV.active_longlived, GV.active_shortlived, GV.inactive_species, GV.num_layers)
+    n_cur_all = compile_ncur_all(n, n_horiz, n_short, GV.n_inactive; GV.active_longlived, GV.active_shortlived, GV.inactive_species, GV.num_layers)
+
+    update_Jrates!(n_cur_all, n_horiz; GV.Jratelist, GV.crosssection, GV.num_layers, GV.absorber, GV.dz, GV.solarflux, enable_horiz_transport=GV.enable_horiz_transport)
 
-    update_Jrates!(n_cur_all; GV.Jratelist, GV.crosssection, GV.num_layers, GV.absorber, GV.dz, GV.solarflux)
     # copy all the Jrates into an external dictionary for storage
     for jr in GV.Jratelist                # time for this is ~0.000005 s
         global external_storage[jr] = n_cur_all[jr]
     end
 
-    # Retrieve Jrates 
-    Jrates = deepcopy(ftype_ncur[external_storage[jr][ialt] for jr in GV.Jratelist, ialt in 1:GV.num_layers])
+    # Retrieve Jrates (MULTICOL UPDATE: Jrates now explicitly have dimensions [species, ihoriz, ialt])
+    Jrates = deepcopy([ftype_ncur(external_storage[jr][ihoriz][ialt]) for jr in GV.Jratelist, ihoriz in 1:n_horiz, ialt in 1:GV.num_layers])
 
     # set the concentrations of species assumed to be in photochemical equilibrium. 
     n_short_updated = set_concentrations!(external_storage, n, n_short, GV.n_inactive, Jrates, M, E; 
                                           GV.active_longlived, GV.active_shortlived, GV.inactive_species, GV.Tn, GV.Ti, GV.Te, GV.num_layers)
 
     # Reconstruct the dictionary that holds densities
-    updated_ncur_all = compile_ncur_all(n, n_short_updated, GV.n_inactive; GV.active_longlived, GV.active_shortlived, GV.inactive_species, GV.num_layers)
+    updated_ncur_all = compile_ncur_all(n, n_horiz, n_short_updated, GV.n_inactive; GV.active_longlived, GV.active_shortlived, GV.inactive_species, GV.num_layers)
 
     # Get the updated transport coefficients, taking into account short-lived species update
-    tlower, tup, tdown, tupper = update_transport_coefficients(GV.transport_species, updated_ncur_all, D_arr, M; 
+    tlower, tup, tdown, tupper = update_transport_coefficients(GV.transport_species, updated_ncur_all, D_arr, M, n_horiz; 
+                                                               calc_nonthermal=nontherm, results_dir, sim_folder_name, 
+                                                               Jratedict=Dict([j=>n_cur_all[j] for j in GV.Jratelist]), # Needed for nonthermal BCs
+                                                               globvars...)
+
+    tbackedge, tforwards, tbackwards, tfrontedge = update_horiz_transport_coefficients(GV.transport_species, updated_ncur_all, D_arr, M, n_horiz; 
                                                                calc_nonthermal=nontherm, results_dir, sim_folder_name, 
                                                                Jratedict=Dict([j=>n_cur_all[j] for j in GV.Jratelist]), # Needed for nonthermal BCs
                                                                globvars...)
 
-    return (ratefn(n, n_short_updated, GV.n_inactive, Jrates, tup, tdown, tlower, tupper, M, E; globvars...), 
-            chemJmat(n, n_short, GV.n_inactive, Jrates, tup, tdown, tlower, tupper, M, E; globvars...) ) 
+    return (ratefn(n, n_short_updated, GV.n_inactive, Jrates, tup, tdown, tlower, tupper, tforwards, tbackwards, tfrontedge, tbackedge, M, E; globvars...),
+            chemJmat(n, n_short, GV.n_inactive, Jrates, tup, tdown, tlower, tupper, tforwards, tbackwards, tfrontedge, tbackedge, M, E; globvars...) )
 end
 
 function next_timestep(nstart, params, t, dt; reltol=1e-2, abstol=1e-12, verbose=false, globvars...)
@@ -706,13 +753,13 @@ function next_timestep(nstart, params, t, dt; reltol=1e-2, abstol=1e-12, verbose
 
     GV = values(globvars)
     @assert all(x->x in keys(GV), [:absorber, :active_species, :active_longlived, :active_shortlived, :all_species, :alt, 
-                                   :collision_xsect, :crosssection, :dz, :e_profile_type, :error_checking_scheme, 
+                                   :collision_xsect, :crosssection, :dz, :dx, :e_profile_type, :error_checking_scheme, 
                                    :H2Oi, :HDOi, :hot_H_network, :hot_H_rc_funcs, :hot_D_network, :hot_D_rc_funcs, 
                                    :hot_H2_network, :hot_H2_rc_funcs, :hot_HD_network, :hot_HD_rc_funcs, :Hs_dict, 
                                    :inactive_species, :ion_species,  :Jratelist, :logfile, :molmass, 
                                    :n_all_layers, :n_alt_index, :n_inactive, :neutral_species, :non_bdy_layers, :num_layers, 
-                                   :plot_grid, :polarizability, :q, :reaction_network,  :speciesbclist, :speciescolor, :speciesstyle, :Te, :Ti, :Tn, :Tp, 
-                                   :Tprof_for_diffusion, :upper_lower_bdy_i, :zmax])
+                                   :plot_grid, :polarizability, :q, :reaction_network,  :speciesbclist, :speciesbclist_horiz, :speciescolor, :speciesstyle,
+                                   :Te, :Ti, :Tn, :Tp, :Tprof_for_diffusion, :upper_lower_bdy_i, :zmax, :horiz_wind_v, :enable_horiz_transport])
 
     # absolute and relative tolerance on rate update
     f_abstol = 1e-2
@@ -844,16 +891,16 @@ end
 
 function set_concentrations!(external_storage, n_active_long, n_active_short, n_inactive, Jrates, M, E; globvars...) 
     #=
-    at each altitude, sets the concentrations for short-lived species assumed to be in photochemical equilibrium
-    and sends them back into the storage dictionary, external_storage
+    At each altitude and horizontal column, sets the concentrations for short-lived species assumed to be in photochemical equilibrium
+    and sends them back into the storage dictionary, external_storage.
 
     Inputs:
         external_storage: dictionary storing densities for short-lived and inactive species, as well as Jrates.
         n_active_short, n_active_long, n_inactive: density of short-lived, long-lived, and inactive species
         active_shortlived, active_longlived, inactive_species: list of short- and long-lived species names
-        Jrates: Jrates for each species, for a particular altitude
-        M: Total atmospheric density
-        E: electron density profile
+        Jrates: Jrates for each species, for each altitude and horizontal column
+        M: Total atmospheric density for each altitude and horizontal column
+        E: Electron density profile for each horizontal column
     Outputs:
         Updates the contents of external_storage.
 
@@ -863,52 +910,71 @@ function set_concentrations!(external_storage, n_active_long, n_active_short, n_
 
     GV = values(globvars)
     @assert all(x->x in keys(GV), [:active_longlived, :active_shortlived, :inactive_species, :Tn, :Ti, :Te, :num_layers])
-    
-    # rows = species, columns = altitudes. 
-    nmat_shortlived = reshape(n_active_short, (length(GV.active_shortlived), GV.num_layers))
-    
-    # auxiliary information that is needed. 
-    nmat_longlived = reshape(n_active_long, (length(GV.active_longlived), GV.num_layers))
-    nmat_inactive = reshape(n_inactive, (length(GV.inactive_species), GV.num_layers))
-    
-    # storage for the updated concentrations
+
+    # === MULTICOL UPDATE === #
+    # rows = species, columns = altitudes, third dim = horizontal columns.
+    nmat_shortlived = reshape(n_active_short, (length(GV.active_shortlived), GV.num_layers, n_horiz))
+    nmat_longlived  = reshape(n_active_long,  (length(GV.active_longlived),  GV.num_layers, n_horiz))
+    nmat_inactive   = reshape(n_inactive,     (length(GV.inactive_species),   GV.num_layers, n_horiz))
+
+    # storage for the updated concentrations (species × altitude × horizontal column)
     new_densities = zeros(size(nmat_shortlived))
-    # dist_zero = zeros(length(nmat_shortlived)) # TODO: Figure out how to make useful
 
-    # fill the first altitude entry with information for all species   
-    argvec = [nmat_shortlived[:,1]; nmat_longlived[:, 1]; nmat_inactive[:, 1]; Jrates[:, 1]; GV.Tn[1]; GV.Ti[1]; GV.Te[1]; M[1]; E[1]] # E FIX ATTEMPT
-    argvec = convert(Array{ftype_chem}, argvec)
-    new_densities[:,1] .= set_concentrations_local(argvec...)
-    # dist_zero[1] = check_zero_distance([nmat_shortlived[:,1]; nmat_longlived[:, 1]; nmat_inactive[:, 1]; Jrates[:, 1]; Tn[1]; Ti[1]; Te[1]]...)
+    # === MULTICOL UPDATE: loop through each horizontal column === #
+    for ihoriz in 1:n_horiz
+
+        # fill the first altitude entry with information for all species   
+        argvec = [nmat_shortlived[:,1,ihoriz];
+                  nmat_longlived[:,1,ihoriz];
+                  nmat_inactive[:,1,ihoriz];
+                  Jrates[:,ihoriz,1];
+                  GV.Tn[ihoriz,1]; GV.Ti[ihoriz,1]; GV.Te[ihoriz,1];
+                  M[1, ihoriz]; E[ihoriz][1]]
 
-    # iterate through other altitudes in the lower atmosphere
-    for ialt in 2:(GV.num_layers-1)
-        argvec = [nmat_shortlived[:,ialt]; nmat_longlived[:, ialt]; nmat_inactive[:, ialt]; Jrates[:, ialt]; GV.Tn[ialt]; GV.Ti[ialt]; GV.Te[ialt]; M[ialt]; E[ialt]] # E FIX ATTEMPT
         argvec = convert(Array{ftype_chem}, argvec)
-        new_densities[:,ialt] .= set_concentrations_local(argvec...)
-        # dist_zero[ialt] = check_zero_distance([nmat_shortlived[:,ialt]; nmat_longlived[:, ialt]; nmat_inactive[:, ialt]; Jrates[:, ialt]; Tn[ialt]; Ti[ialt]; Te[ialt]]...)
+        new_densities[:,1,ihoriz] .= set_concentrations_local(argvec...)
+
+        # iterate through other altitudes in the lower atmosphere
+        for ialt in 2:(GV.num_layers-1)
+            argvec = [nmat_shortlived[:,ialt,ihoriz];
+                      nmat_longlived[:,ialt,ihoriz];
+                      nmat_inactive[:,ialt,ihoriz];
+                      Jrates[:,ihoriz,ialt];
+                      GV.Tn[ihoriz,ialt]; GV.Ti[ihoriz,ialt]; GV.Te[ihoriz,ialt];
+                      M[ialt, ihoriz]; E[ihoriz][ialt]]
+
+            argvec = convert(Array{ftype_chem}, argvec)
+            new_densities[:,ialt,ihoriz] .= set_concentrations_local(argvec...)
+        end
+
+        # fill in the last altitude level
+        argvec = [nmat_shortlived[:,end,ihoriz];
+                  nmat_longlived[:,end,ihoriz];
+                  nmat_inactive[:,end,ihoriz];
+                  Jrates[:,ihoriz,end];
+                  GV.Tn[ihoriz,end]; GV.Ti[ihoriz,end]; GV.Te[ihoriz,end];
+                  M[end, ihoriz]; E[ihoriz][end]]
+
+        argvec = convert(Array{ftype_chem}, argvec)
+        new_densities[:,end,ihoriz] .= set_concentrations_local(argvec...)
     end
 
-    # fill in the last level of altitude
-    argvec = [nmat_shortlived[:, end]; nmat_longlived[:, end]; nmat_inactive[:, end]; Jrates[:, end]; GV.Tn[end]; GV.Ti[end]; GV.Te[end]; M[end]; E[end]] # E FIX ATTEMPT
-    argvec = convert(Array{ftype_chem}, argvec)
-    new_densities[:,end] .= set_concentrations_local(argvec...)
-    # dist_zero[end] = check_zero_distance([nmat_shortlived[:, end]; nmat_longlived[:, end]; nmat_inactive[:, end]; Jrates[:, end]; Tn[end]; Ti[end]; Te[end]]...)
-    
-    # write out the new densities for shortlived species to the external storage
+    # === MULTICOL UPDATE: write out the new densities for short-lived species to external storage === #
     for (s, ssp) in enumerate(GV.active_shortlived)
-        external_storage[ssp] .= new_densities[s, :]
+        for ihoriz in 1:n_horiz
+            external_storage[ssp][ihoriz] .= new_densities[s, :, ihoriz]
+        end
     end
-    
+
     return vec(new_densities)
 
-    # Look at distance from zero
+    # Look at distance from zero (outdated?)
     # if any(x->x>100, dist_zero)
     #     println("elements >100 from zero: $(dist_zero[findall(x->x>100, dist_zero)])")
     # end
 end
 
-function update!(n_current::Dict{Symbol, Array{ftype_ncur, 1}}, t, dt; abstol=1e-12, reltol=1e-2, globvars...)
+function update!(n_current::Dict{Symbol, Vector{Array{ftype_ncur}}}, t, dt; abstol=1e-12, reltol=1e-2, globvars...)
     #= 
     update n_current using the coupled reaction network, moving to the next timestep.
     Input:
@@ -921,36 +987,42 @@ function update!(n_current::Dict{Symbol, Array{ftype_ncur, 1}}, t, dt; abstol=1e
 
     GV = values(globvars)
     @assert all(x->x in keys(GV), [:absorber, :active_species, :active_longlived, :active_shortlived, :all_species, :alt, :crosssection, 
-                                   :Dcoef_arr_template, :dz, :e_profile_type, :error_checking_scheme, :H2Oi, :HDOi, :Hs_dict, 
+                                   :Dcoef_arr_template, :dz, :dx, :e_profile_type, :error_checking_scheme, :H2Oi, :HDOi, :Hs_dict, 
                                    :inactive_species, :ion_species, :Jratelist, :logfile, :molmass, 
                                    :n_all_layers, :n_alt_index, :n_inactive, :neutral_species, :non_bdy_layers, :num_layers, 
-                                   :plot_grid, :polarizability, :q, :reaction_network, :solarflux, :speciesbclist, :speciescolor, :speciesstyle, :Te, :Ti, :Tn, :Tp, :Tprof_for_diffusion, 
-                                   :upper_lower_bdy_i, :zmax,])
-        
+                                   :plot_grid, :polarizability, :q, :reaction_network, :solarflux, :speciesbclist, :speciesbclist_horiz, :speciescolor, :speciesstyle,
+                                   :Te, :Ti, :Tn, :Tp, :Tprof_for_diffusion, :upper_lower_bdy_i, :zmax, :horiz_wind_v, :enable_horiz_transport])
 
-    M = n_tot(n_current; GV.all_species) 
-    E = electron_density(n_current; GV.e_profile_type, GV.non_bdy_layers, GV.ion_species)
+    # MULTICOL UPDATE: calculate total atmospheric density for each horizontal column separately
+    M = zeros(GV.num_layers, n_horiz)
+    for ihoriz in 1:n_horiz
+        M[:, ihoriz] = n_tot(n_current, ihoriz; GV.all_species)
+    end
+    E = electron_density(n_current; GV.e_profile_type, GV.non_bdy_layers, GV.ion_species, n_horiz)
 
     # global params for simulation
-    params = [GV.Dcoef_arr_template, M, E] 
+    params = [GV.Dcoef_arr_template, M, E]
 
     # get current long-lived species concentrations
-    nstart = flatten_atm(n_current, GV.active_longlived; GV.num_layers)
+    nstart = flatten_atm(n_current, GV.active_longlived, n_horiz; GV.num_layers)
 
     # update to next timestep
     nend = next_timestep(nstart, params, t, dt; abstol=abstol, reltol=reltol, globvars...)
-    #    println("max(nend-nstart) = $(max((nend-nstart)...))")
 
-    # retrieve the shortlived species from their storage and flatten them
-    n_short = flatten_atm(external_storage, GV.active_shortlived; GV.num_layers)  
+    # retrieve the short-lived species from their storage and flatten them
+    n_short = flatten_atm(external_storage, GV.active_shortlived, n_horiz; GV.num_layers)
 
-    n_current = compile_ncur_all(nend, n_short, GV.n_inactive; GV.active_longlived, GV.active_shortlived, GV.inactive_species, GV.num_layers)
+    n_current = compile_ncur_all(nend, n_horiz, n_short, GV.n_inactive; GV.active_longlived, GV.active_shortlived, GV.inactive_species, GV.num_layers)
 
     # ensure Jrates are included in n_current
-    update_Jrates!(n_current; GV.Jratelist, GV.crosssection, GV.num_layers, GV.absorber, GV.dz, GV.solarflux)
+    update_Jrates!(n_current, n_horiz; GV.Jratelist, GV.crosssection, GV.num_layers, GV.absorber, GV.dz, GV.solarflux, enable_horiz_transport=GV.enable_horiz_transport)
+
+    # Optionally adjust Jrates per horizontal column (commented out)
+    # solarflux_multipliers = [1.0, 0.5, 2.0]
+    # update_Jrates!(n_current, n_horiz; GV.Jratelist, GV.crosssection, GV.num_layers, GV.absorber, GV.dz, GV.solarflux, solarflux_multipliers=solarflux_multipliers)
 
     return n_current
-end 
+end
 
 
 # **************************************************************************** #
@@ -990,7 +1062,7 @@ const hot_HD_rc_funcs = Dict([rxn => mk_function(:((Tn, Ti, Te, M) -> $(rxn[3]))
 if make_new_alt_grid==true
     throw("The code for extending the altitude grid needs to be redone.")
     # const alt = convert(Array, (0:2e5:200e5))
-    # n_current = get_ncurrent(initial_atm_file)
+    # n_current = get_ncurrent(initial_atm_file, n_horiz)
 
     # new_zmax = parse(Int64, input("Enter the new top of the atmosphere in km: "))
     # extra_entries = Int64((new_zmax - (zmax / 1e5))/(dz/1e5))
@@ -1004,15 +1076,17 @@ if make_new_alt_grid==true
     # const max_alt = new_zmax*1e5
 elseif make_new_alt_grid==false 
     println("$(Dates.format(now(), "(HH:MM:SS)")) Loading atmosphere")
-    n_current = get_ncurrent(initial_atm_file)
+    n_current = get_ncurrent(initial_atm_file, n_horiz)
 end
 
 
 #                 Set the boundary altitude below which water is fixed          #
 #===============================================================================#
-
-H2Osatfrac = H2Osat ./ map(z->n_tot(n_current, z; all_species, n_alt_index), alt)  # get SVP as fraction of total atmo
-const upper_lower_bdy = alt[something(findfirst(isequal(minimum(H2Osatfrac)), H2Osatfrac), 0)] # in cm
+H2Osatfrac = zeros(num_layers, n_horiz)
+for ihoriz in 1:n_horiz
+    H2Osatfrac[:, ihoriz] = H2Osat[2:end-1] ./ map(z -> n_tot(n_current, z, ihoriz; all_species, n_alt_index), alt[2:end-1]) # get SVP as fraction of total atmo
+end
+const upper_lower_bdy = alt[2:end-1][something(findfirst(isequal(minimum(H2Osatfrac[:, 1])), H2Osatfrac[:, 1]), 0)] # in cm
 const upper_lower_bdy_i = n_alt_index[upper_lower_bdy]  # the uppermost layer at which water will be fixed, in cm
 # Control whether the removal of rates etc at "Fixed altitudes" runs. If the boundary is 
 # the bottom of the atmosphere, we shouldn't do it at all.
@@ -1114,7 +1188,7 @@ end
 
 #                        Initialize electron profile                            #
 #===============================================================================#
-E = electron_density(n_current; e_profile_type, non_bdy_layers, ion_species)
+E = electron_density(n_current; e_profile_type, non_bdy_layers, ion_species, n_horiz)
 
 #                          Set up the water profile                             #
 #===============================================================================#
@@ -1131,14 +1205,13 @@ if reinitialize_water_profile
                                         hygropause_alt=hygropause_alt, excess_water_in=water_loc, 
                                         all_species, alt, DH, num_layers, non_bdy_layers, n_alt_index, planet, plot_grid,
                                         H2O_excess, HDO_excess,  H2Osat, water_mixing_ratio,  results_dir, 
-                                        sim_folder_name, speciescolor, speciesstyle, upper_lower_bdy_i, monospace_choice, sansserif_choice)
+                                        sim_folder_name, speciescolor, speciesstyle, upper_lower_bdy_i, monospace_choice, sansserif_choice, n_horiz, enable_horiz_transport)
     elseif planet=="Mars"
         setup_water_profile!(n_current; dust_storm_on=dust_storm_on, water_amt=water_case, ffac=f_fac_opts[water_case], ealt=add_water_alt_opts[water_case], 
                                         hygropause_alt=hygropause_alt, excess_water_in=water_loc, 
                                         all_species, alt, DH, num_layers, non_bdy_layers, n_alt_index, planet, plot_grid,
                                         H2O_excess, HDO_excess,  H2Osat, water_mixing_ratio,  results_dir, 
-                                        sim_folder_name, speciescolor, speciesstyle, upper_lower_bdy_i, monospace_choice, sansserif_choice)
-
+                                        sim_folder_name, speciescolor, speciesstyle, upper_lower_bdy_i, monospace_choice, sansserif_choice, n_horiz, enable_horiz_transport)
     end
 end
 
@@ -1149,14 +1222,20 @@ if update_water_profile
     if water_case!="standard"
         if water_loc=="loweratmo"
 
-            # Recalculate the initialization fraction for H2O 
-            H2Oinitfrac = set_h2oinitfrac_bySVP(n_current, hygropause_alt; all_species, alt, num_layers, n_alt_index, H2Osat, water_mixing_ratio)
-
+            # Recalculate the initialization fraction for H2O in each column
+            H2Oinitfrac = [set_h2oinitfrac_bySVP(n_current, hygropause_alt;
+                                                ihoriz=ihoriz, all_species, alt, num_layers,
+                                                n_alt_index, H2Osat, water_mixing_ratio)[1]
+                           for ihoriz in 1:n_horiz]
+            
             prevh2o = deepcopy(n_current[:H2O])
             prevhdo = deepcopy(n_current[:HDO])
 
-            n_current[:H2O][1:upper_lower_bdy_i] = H2Oinitfrac[1:upper_lower_bdy_i] .* n_tot(n_current; n_alt_index, all_species)[1:upper_lower_bdy_i]
-            n_current[:HDO][1:upper_lower_bdy_i] = 2 * DH * n_current[:H2O][1:upper_lower_bdy_i]
+            for ihoriz in 1:n_horiz
+                ntot_col = n_tot(n_current, ihoriz; n_alt_index, all_species)
+                n_current[:H2O][ihoriz][1:upper_lower_bdy_i] .= H2Oinitfrac[ihoriz][1:upper_lower_bdy_i] .* ntot_col[1:upper_lower_bdy_i]
+                n_current[:HDO][ihoriz][1:upper_lower_bdy_i] .= 2 * DH * n_current[:H2O][ihoriz][1:upper_lower_bdy_i]
+            end
         else 
             # Create the new multipliers to change the profiles
             multiplier = water_tanh_prof(non_bdy_layers./1e5; f=f_fac_opts[water_case], z0=add_water_alt_opts[water_case])
@@ -1175,36 +1254,49 @@ if update_water_profile
         end
 
         # Make the plot
-        plot_water_profile(n_current, results_dir*sim_folder_name; prev_profs=[prevh2o, prevhdo], plot_grid, all_species, non_bdy_layers, speciescolor, speciesstyle,
-                                                                   monospace_choice, sansserif_choice) 
+        plot_water_profile(n_current, results_dir*sim_folder_name; ihoriz=1, prev_profs=[prevh2o, prevhdo], plot_grid, all_species, non_bdy_layers, speciescolor, speciesstyle,
+                                                                   monospace_choice, sansserif_choice)
     else
-        # Recalculate the initialization fraction for H2O 
-        H2Oinitfrac, H2Osatfrac = set_h2oinitfrac_bySVP(n_current, hygropause_alt; all_species, alt, num_layers, n_alt_index, H2Osat, water_mixing_ratio)
-
+        # Recalculate the initialization fraction for H2O for each column
+        H2Oinitfrac = Vector{Vector{ftype_ncur}}(undef, n_horiz)
+        H2Osatfrac = Vector{Vector{ftype_ncur}}(undef, n_horiz)
+        for ihoriz in 1:n_horiz
+            H2Oinitfrac[ihoriz], H2Osatfrac[ihoriz] = set_h2oinitfrac_bySVP(n_current, hygropause_alt;
+                                                                    ihoriz=ihoriz, all_species, alt,
+                                                                    num_layers, n_alt_index,
+                                                                    H2Osat, water_mixing_ratio)
+        end
+        
         prevh2o = deepcopy(n_current[:H2O])
         prevhdo = deepcopy(n_current[:HDO])
 
         if modified_water_alts == "below fixed point"
             # in this case, we are going to re-set the lower atmosphere directly
             # but not change the upper atmosphere from whatever it previously was.
-            n_current[:H2O][1:upper_lower_bdy_i] = H2Oinitfrac[1:upper_lower_bdy_i] .* n_tot(n_current; n_alt_index, all_species)[1:upper_lower_bdy_i]
-            n_current[:HDO][1:upper_lower_bdy_i] = 2 * DH * n_current[:H2O][1:upper_lower_bdy_i]
+            for ihoriz in 1:n_horiz
+                ntot_col = n_tot(n_current, ihoriz; n_alt_index, all_species)
+                n_current[:H2O][ihoriz][1:upper_lower_bdy_i] .= H2Oinitfrac[ihoriz][1:upper_lower_bdy_i] .* ntot_col[1:upper_lower_bdy_i]
+                n_current[:HDO][ihoriz][1:upper_lower_bdy_i] .= 2 * DH * n_current[:H2O][ihoriz][1:upper_lower_bdy_i]
+            end
         elseif modified_water_alts == "above fixed point"
             # in this case, we modify the upper atmosphere. For some reason. Probably never do this.
-            n_current[:H2O][upper_lower_bdy_i+1:end] = H2Oinitfrac[upper_lower_bdy_i+1:end] .* n_tot(n_current; n_alt_index, all_species)[upper_lower_bdy_i+1:end]
-            n_current[:HDO][upper_lower_bdy_i+1:end] = 2 * DH * n_current[:H2O][upper_lower_bdy_i+1:end]
+            for ihoriz in 1:n_horiz
+                ntot_col = n_tot(n_current, ihoriz; n_alt_index, all_species)
+                n_current[:H2O][ihoriz][upper_lower_bdy_i+1:end] .= H2Oinitfrac[ihoriz][upper_lower_bdy_i+1:end] .* ntot_col[upper_lower_bdy_i+1:end]
+                n_current[:HDO][ihoriz][upper_lower_bdy_i+1:end] .= 2 * DH * n_current[:H2O][ihoriz][upper_lower_bdy_i+1:end]
+            end
         end
 
         # Now plot it
-        plot_water_profile(n_current, results_dir*sim_folder_name; prev_profs=[prevh2o, prevhdo], plot_grid, all_species, non_bdy_layers, speciescolor, speciesstyle,
-                                                                   monospace_choice, sansserif_choice) 
+        plot_water_profile(n_current, results_dir*sim_folder_name; ihoriz=1, prev_profs=[prevh2o, prevhdo], plot_grid, all_species, non_bdy_layers, speciescolor, speciesstyle,
+                                                                   monospace_choice, sansserif_choice)
         println("I have reset the water profile to the standard initial mixing fraction $(modified_water_alts)")
     end
 end
 
 # Calculate precipitable microns, including boundary layers (assumed same as nearest bulk layer)
-H2Oprum = precip_microns(:H2O, [n_current[:H2O][1]; n_current[:H2O]; n_current[:H2O][end]]; molmass, dz)
-HDOprum = precip_microns(:HDO, [n_current[:HDO][1]; n_current[:HDO]; n_current[:HDO][end]]; molmass, dz)
+H2Oprum = [precip_microns(:H2O, [n_current[:H2O][ihoriz][1]; n_current[:H2O][ihoriz]; n_current[:H2O][ihoriz][end]]; molmass, dz) for ihoriz in 1:n_horiz]
+HDOprum = [precip_microns(:HDO, [n_current[:HDO][ihoriz][1]; n_current[:HDO][ihoriz]; n_current[:HDO][ihoriz][end]]; molmass, dz) for ihoriz in 1:n_horiz]
 
 #           Define storage for species/Jrates not solved for actively           #
 #===============================================================================#
@@ -1212,9 +1304,10 @@ HDOprum = precip_microns(:HDO, [n_current[:HDO][1]; n_current[:HDO]; n_current[:
 # outside of the primary ODE solver. Inactive species never change during simulation.
 # Jrates must be stored here because they have to be updated alongside evolution
 # of the atmospheric densities--the solver doesn't handle their values currently.
+
 # NOTE: The stored Jrates will have units of #/s.
-const external_storage = Dict{Symbol, Vector{Float64}}([j=>n_current[j] for j in union(short_lived_species, inactive_species, Jratelist)])
-const n_inactive = flatten_atm(n_current, inactive_species; num_layers)
+# const external_storage = Dict{Symbol, Vector{Array{Float64}}}([j=>n_current[j] for j in union(short_lived_species, inactive_species, Jratelist)])
+# const n_inactive = flatten_atm(n_current, inactive_species, n_horiz; num_layers)
 
 # **************************************************************************** #
 #                                                                              #
@@ -1237,7 +1330,7 @@ println("$(Dates.format(now(), "(HH:MM:SS)")) Setting up transport network, chem
 
 #                               Transport network                               #
 #===============================================================================#
-
+# Vertical transport
 const upeqns = [Any[Any[[s], [Symbol(string(s)*"_above")],Symbol("t"*string(s)*"_up")],
                     Any[[Symbol(string(s)*"_above")],[s],Symbol("t"*string(s)*"_above_down")]]
                     for s in transport_species];
@@ -1253,24 +1346,47 @@ const local_transport_rates = [[[Symbol("t"*string(s)*"_up") for s in transport_
 
 const transportnet = [[upeqns...;]; [downeqns...;]];
 
+# Horizontal transport
+const fweqns = [Any[Any[[s], [Symbol(string(s)*"_infront")],Symbol("t"*string(s)*"_forwards")],
+                    Any[[Symbol(string(s)*"_infront")],[s],Symbol("t"*string(s)*"_infront_backwards")]]
+                    for s in transport_species];
+
+const bweqns = [Any[Any[[s], [Symbol(string(s)*"_behind")],Symbol("t"*string(s)*"_backwards")],
+                      Any[[Symbol(string(s)*"_behind")],[s],Symbol("t"*string(s)*"_behind_forwards")]]
+                      for s in transport_species];
+
+const local_transport_rates_horiz = [[[Symbol("t"*string(s)*"_forwards") for s in transport_species]
+                                [Symbol("t"*string(s)*"_backwards") for s in transport_species]
+                                [Symbol("t"*string(s)*"_infront_backwards") for s in transport_species]
+                                [Symbol("t"*string(s)*"_behind_forwards") for s in transport_species]]...;];
+
+const transportnet_horiz = [[fweqns...;]; [bweqns...;]];
+
 # define names for all the species active in the coupled rates:
 const active_longlived_above = [Symbol(string(s)*"_above") for s in active_longlived];
 const active_longlived_below = [Symbol(string(s)*"_below") for s in active_longlived];
+const active_longlived_behind  = [Symbol(string(s)*"_behind") for s in active_longlived]; # FOR MULTICOL
+const active_longlived_infront = [Symbol(string(s)*"_infront") for s in active_longlived]; # FOR MULTICOL
 
 #                               Chemical jacobian                               #
 #===============================================================================#
-# Create symbolic expressions for the chemical jacobian at a local layer with influence from that same layer, 
-# the one above, and the one below
-const chemJ_local = chemical_jacobian(active_longlived, active_longlived; diff_wrt_e=ediff, diff_wrt_m=mdiff, ion_species, chem_species, transport_species, chemnet=reaction_network, transportnet);
-const chemJ_above = chemical_jacobian(active_longlived, active_longlived_above; diff_wrt_e=ediff, diff_wrt_m=mdiff, ion_species, chem_species, transport_species, chemnet=reaction_network, transportnet);
-const chemJ_below = chemical_jacobian(active_longlived, active_longlived_below; diff_wrt_e=ediff, diff_wrt_m=mdiff, ion_species, chem_species, transport_species, chemnet=reaction_network, transportnet);
+# Create symbolic expressions for the chemical jacobian at a local layer with influence from that same layer,
+# the one above, and the one below, including horizontal transport terms
+const chemJ_local = chemical_jacobian(active_longlived, active_longlived; diff_wrt_e=ediff, diff_wrt_m=mdiff, transportnet_horiz, ion_species, chem_species, transport_species, chemnet=reaction_network, transportnet);
+const chemJ_above = chemical_jacobian(active_longlived, active_longlived_above; diff_wrt_e=ediff, diff_wrt_m=mdiff, transportnet_horiz, ion_species, chem_species, transport_species, chemnet=reaction_network, transportnet);
+const chemJ_below = chemical_jacobian(active_longlived, active_longlived_below; diff_wrt_e=ediff, diff_wrt_m=mdiff, transportnet_horiz, ion_species, chem_species, transport_species, chemnet=reaction_network, transportnet);
+const chemJ_infront = chemical_jacobian(active_longlived, active_longlived_infront; diff_wrt_e=ediff, diff_wrt_m=mdiff, transportnet_horiz, ion_species, chem_species, transport_species, chemnet=reaction_network, transportnet);
+const chemJ_behind = chemical_jacobian(active_longlived, active_longlived_behind; diff_wrt_e=ediff, diff_wrt_m=mdiff, transportnet_horiz, ion_species, chem_species, transport_species, chemnet=reaction_network, transportnet);
 
 #                     Photochemical equilibrium setup                           #
 #===============================================================================#
 
-const active_longlived_species_rates, short_lived_density_eqn, 
-      shortlived_density_inputs, equilibrium_eqn_terms = setup_photochemical_equilibrium(; active_longlived, active_shortlived, short_lived_species, reaction_network, 
-                                                                                           transportnet, chem_species, transport_species)
+# const active_longlived_species_rates, short_lived_density_eqn, 
+#       shortlived_density_inputs, equilibrium_eqn_terms = setup_photochemical_equilibrium(; active_longlived, active_shortlived, short_lived_species, reaction_network, 
+#                                                                                            transportnet, chem_species, transport_species)
+const active_longlived_species_rates, short_lived_density_eqn,
+      shortlived_density_inputs, equilibrium_eqn_terms = setup_photochemical_equilibrium(; active_longlived, active_shortlived, short_lived_species, reaction_network,
+          transportnet, transportnet_horiz, chem_species, transport_species)
 
 # **************************************************************************** #
 #                                                                              #
@@ -1280,10 +1396,17 @@ const active_longlived_species_rates, short_lived_density_eqn,
 
 #          Arguments and expressions for metaprogramming functions              #
 #===============================================================================#
-const ratefn_arglist = [active_longlived; active_longlived_above; active_longlived_below; active_shortlived; inactive_species; Jratelist; 
-                        :Tn; :Ti; :Te; :M; :E; local_transport_rates]; # E FIX ATTEMPT
+const ratefn_arglist = [active_longlived;
+                        active_longlived_above;
+                        active_longlived_below;
+                        active_longlived_behind;
+                        active_longlived_infront;
+                        active_shortlived;
+                        inactive_species; Jratelist;
+                        :Tn; :Ti; :Te; :M; :E;
+                        local_transport_rates; local_transport_rates_horiz];
 const ratefn_arglist_typed = [:($s::ftype_chem) for s in ratefn_arglist];
-const set_concentration_arglist = [active_shortlived; active_longlived; inactive_species; Jratelist; :Tn; :Ti; :Te; :M; :E]; # E FIX ATTEMPT
+const set_concentration_arglist = [active_shortlived; active_longlived; inactive_species; Jratelist; :Tn; :Ti; :Te; :M; :E];
 const set_concentration_arglist_typed = [:($s::ftype_chem) for s in set_concentration_arglist];
 
 # This can be used if you want to calculate M, E at computation
@@ -1310,9 +1433,9 @@ const set_concentration_arglist_typed = [:($s::ftype_chem) for s in set_concentr
         =#
 
         # M and E are calculated here to ensure that the right number of ions/electrons
-        # is used. 
+        # is used.
         # M = $Mexpr
-        # E = $Eexpr # E FIX ATTEMPT
+        # E = $Eexpr
 
         # stack overflow - answer (Cite)
         # create a result array for evaluating the production and loss expressions
@@ -1380,8 +1503,8 @@ end
         =#
 
         # M = $Mexpr
-        # E = $Eexpr  # E FIX ATTEMPT
-         
+        # E = $Eexpr
+        
         # Make a result array in which to store evaluated expressions 
         density_result = map(_ -> 0., $short_lived_density_eqn)  # will hold evaluated expressions.
         evaluated_inputs = map(_ -> 0., $shortlived_density_inputs) 
@@ -1439,7 +1562,7 @@ end
         #=
         Generates a matrix of I, J, and V values for a sparse matrix, for the 
         local layer, for influences from the layer above, and influences 
-        from the layer below. 
+        from the layer below as well as adjacent columns.
         =#
 
         # M = $Mexpr 
@@ -1457,10 +1580,21 @@ end
         belowchemJj = $(chemJ_below[2])
         belowchemJval = convert(Array{ftype_ncur}, $(Expr(:vcat, chemJ_below[3]...)))
 
+        # Here, 'behind' refers to vertical column ihoriz-1 and 'infront' refers to vertical column ihoriz+1, where ihoriz is the index of the current column
+        behindchemJi = $(chemJ_behind[1])
+	    behindchemJj = $(chemJ_behind[2])
+        behindchemJval = convert(Array{ftype_ncur}, $(Expr(:vcat, chemJ_behind[3]...)))
+
+        infrontchemJi = $(chemJ_infront[1])
+        infrontchemJj = $(chemJ_infront[2])
+        infrontchemJval = convert(Array{ftype_ncur}, $(Expr(:vcat, chemJ_infront[3]...)))
+
         # return the actual values of I, J, and V (indices and numerical value):
         return ((localchemJi, localchemJj, localchemJval),
                 (abovechemJi, abovechemJj, abovechemJval),
-                (belowchemJi, belowchemJj, belowchemJval))
+                (belowchemJi, belowchemJj, belowchemJval),
+		(behindchemJi, behindchemJj, behindchemJval),
+		(infrontchemJi, infrontchemJj, infrontchemJval))
     end
 end
 
@@ -1471,7 +1605,7 @@ end
 # **************************************************************************** #
 println("$(Dates.format(now(), "(HH:MM:SS)")) Populating cross section dictionary...")
 
-const crosssection = populate_xsect_dict(photochem_data_files, xsecfolder; ion_xsects=ions_included, Tn=Tn_arr, n_all_layers)
+const crosssection = populate_xsect_dict(photochem_data_files, xsecfolder; ion_xsects=ions_included, Tn=Tn_arr, n_all_layers, n_horiz)
 
 # **************************************************************************** #
 #                                                                              #
@@ -1482,12 +1616,26 @@ solarflux = readdlm(code_dir*solarfile,'\t', Float64, comments=true, comment_cha
 solarflux[:,2] = solarflux[:,2] * cosd(SZA)  # Adjust the flux according to specified SZA
 
 # pad all cross-sections to solar
-for j in Jratelist, ialt in 1:length(alt)
-    crosssection[j][ialt] = padtosolar(solarflux, crosssection[j][ialt])
+for j in Jratelist, ihoriz in 1:n_horiz, ialt in 1:length(alt)
+    crosssection[j][ihoriz][ialt] = padtosolar(solarflux, crosssection[j][ihoriz][ialt])
 end
 
 # this is the unitialized array for storing values
-solarabs = fill(fill(0.,size(solarflux, 1)), num_layers);
+
+update_Jrates!(n_current, n_horiz;
+               Jratelist=Jratelist,
+               crosssection=crosssection,
+               num_layers=num_layers,
+               absorber=absorber,
+               dz=dz,
+               solarflux=solarflux,
+               enable_horiz_transport=enable_horiz_transport)
+# NOTE: The stored Jrates will have units of #/s.
+const external_storage = Dict{Symbol, Vector{Array{Float64}}}(
+    [j => n_current[j] for j in union(short_lived_species, inactive_species, Jratelist)
+     if haskey(n_current, j)]
+)
+const n_inactive = flatten_atm(n_current, inactive_species, n_horiz; num_layers)
 
 # **************************************************************************** #
 #                                                                              #
@@ -1499,9 +1647,29 @@ println("$(Dates.format(now(), "(HH:MM:SS)")) Creating the simulation log file..
 
 # Boundary condition write out messages
 bc_type = Dict("n"=>"density", "f"=>"thermal flux", "v"=>"velocity", "ntf"=>"nonthermal flux")
-for k in keys(speciesbclist)
-    for k2 in keys(speciesbclist[k])
-        push!(PARAMETERS_BCS, ("$(string(k))", "$(bc_type[string(k2)])", "$(speciesbclist[k][k2][1])", "$(speciesbclist[k][k2][2])")) 
+# for k in keys(speciesbclist)
+#     for k2 in keys(speciesbclist[k])
+#         push!(PARAMETERS_BCS, ("$(string(k))", "$(bc_type[string(k2)])", "$(speciesbclist[k][k2][1])", "$(speciesbclist[k][k2][2])")) 
+for sp in keys(speciesbclist)
+    for bctype in keys(speciesbclist[sp])
+        for ihoriz in 1:length(speciesbclist[sp][bctype])
+            vals = speciesbclist[sp][bctype][ihoriz]
+            push!(PARAMETERS_BCS, (string(sp), bc_type[string(bctype)], ihoriz, vals[1], vals[2]))
+        end
+    end
+end
+
+bc_type_horiz = Dict("n"=>"density", "f"=>"flux", "v"=>"velocity")
+# for k in keys(speciesbclist_horiz)
+#     for k2 in keys(speciesbclist_horiz[k])
+#         push!(PARAMETERS_BCS_HORIZ, ("$(string(k))", "$(bc_type_horiz[string(k2)])", "$(speciesbclist_horiz[k][k2][1])", "$(speciesbclist_horiz[k][k2][2])")) 
+for sp in keys(speciesbclist_horiz)
+    for bctype in keys(speciesbclist_horiz[sp])
+        for ialt in 1:length(speciesbclist_horiz[sp][bctype][1])
+            back_edge = speciesbclist_horiz[sp][bctype][1][ialt]
+            front_edge = speciesbclist_horiz[sp][bctype][2][ialt]
+            push!(PARAMETERS_BCS_HORIZ, (string(sp), bc_type_horiz[string(bctype)], ialt, back_edge, front_edge))
+        end
     end
 end
 
@@ -1528,7 +1696,7 @@ write_to_log(logfile, ["Description: $(optional_logging_note)"], mode="w")
 # n_current[:D] = map(x->1e5*exp(-((x-184)/20)^2), non_bdy_layers/1e5) + n_current[:D]
 
 # write initial atmospheric state ==============================================
-write_atmosphere(n_current, results_dir*sim_folder_name*"/initial_atmosphere.h5"; alt, num_layers, hrshortcode, rshortcode)
+write_atmosphere(n_current, results_dir*sim_folder_name*"/initial_atmosphere.h5", n_horiz; alt, num_layers, hrshortcode, rshortcode)
 
 # Plot initial temperature and water profiles ==================================
 plot_temp_prof(Tn_arr; savepath=results_dir*sim_folder_name, Tprof_2=Ti_arr, Tprof_3=Te_arr, alt, monospace_choice, sansserif_choice)
@@ -1536,16 +1704,21 @@ plot_temp_prof(Tn_arr; savepath=results_dir*sim_folder_name, Tprof_2=Ti_arr, Tpr
 # Absolute tolerance
 if problem_type == "Gear"
     const atol = 1e-12 # absolute tolerance in ppm, used by Gear solver # NOTE: I think this is actually #/cm³ not ppm, because n_i+1 - n_i is compared against it.--Eryn
-    const abs_tol_for_plot = fill(atol, length(n_tot(n_current; all_species)))
+    const abs_tol_for_plot = [fill(atol, length(n_tot(n_current, ihoriz; all_species)))
+                              for ihoriz in 1:n_horiz]
 else
     # absolute tolerance relative to total atmosphere density, used by DifferentialEquations.jl solvers
-    const atol = 1e-12 .* [[n_tot(n_current, a; n_alt_index, all_species) for sp in active_longlived, a in non_bdy_layers]...] 
-    const abs_tol_for_plot = 1e-12 .* n_tot(n_current; n_alt_index, all_species) # calculates 1 ppt of the total density at each altitude.
+    const atol = vcat([1e-12 .* [n_tot(n_current, a, ihoriz; n_alt_index, all_species)
+                                 for sp in active_longlived
+                                 for a in non_bdy_layers]
+                       for ihoriz in 1:n_horiz]...)
+    const abs_tol_for_plot = [1e-12 .* n_tot(n_current, ihoriz; n_alt_index, all_species)
+                              for ihoriz in 1:n_horiz]
 end
     
 # Plot initial atmosphere condition  ===========================================
 println("$(Dates.format(now(), "(HH:MM:SS)")) Plotting the initial condition")
-plot_atm(n_current, results_dir*sim_folder_name*"/initial_atmosphere.png", abs_tol_for_plot, E; ylims=[zmin/1e5, zmax/1e5],
+plot_atm(n_current, results_dir*sim_folder_name*"/initial_atmosphere.png", abs_tol_for_plot, E, n_horiz; ylims=[zmin/1e5, zmax/1e5],
          t="initial state", neutral_species, ion_species, plot_grid, speciescolor, speciesstyle, zmax, hrshortcode, rshortcode,
          monospace_choice, sansserif_choice) 
 
@@ -1585,22 +1758,26 @@ if ftype_ncur==Double64
     println("$(Dates.format(now(), "(HH:MM:SS)")) Compiling and calling the chemical jacobian outside evolve_atmosphere (this will take ~45 min)...")
     write_to_log(logfile, "$(Dates.format(now(), "(HH:MM:SS)")) Started first chemical jacobian compile")
 
-    # Set up the initial state and check for any problems 
-    M = n_tot(n_current; all_species)
-    E = electron_density(n_current; e_profile_type, non_bdy_layers, ion_species)
+    # Set up the initial state and check for any problems
+    M = zeros(GV.num_layers, n_horiz)
+    for ihoriz in 1:n_horiz
+        M[:, ihoriz] = n_tot(n_current, ihoriz; all_species)
+    end
+    E = electron_density(n_current; e_profile_type, non_bdy_layers, ion_species, n_horiz)
 
-    nstart = flatten_atm(n_current, active_longlived; num_layers)
+    nstart = flatten_atm(n_current, active_longlived, n_horiz; num_layers)
     find_nonfinites(nstart, collec_name="nstart")
 
-    # Set up parameters    
-    Dcoef_arr_template = zeros(size(Tn_arr))  # For making diffusion coefficient calculation go faster 
-    params = [#inactive, inactive_species, active_species, active_longlived, active_shortlived, Tn_arr, Ti_arr, Te_arr, Tplasma_arr, 
-              Dcoef_arr_template, M, E] # E FIX ATTEMPT
+    # Set up parameters
+    Dcoef_arr_template = [zeros(size(Tn_arr)) for ihoriz in 1:n_horiz] # For making diffusion coefficient calculation go faster
+    params = [#inactive, inactive_species, active_species, active_longlived, active_shortlived, Tn_arr, Ti_arr, Te_arr, Tplasma_arr,
+              Dcoef_arr_template, M, E]
     params_exjac = deepcopy(params)  # I think this is so the Dcoef doesn't get filled in with the wrong info?
 
     # Call the expensive rate function
     t_before_jac = time()
-    dndt, example_jacobian = get_rates_and_jacobian(nstart, params_exjac, 0.0) # TODO: Fill in global variables 
+    # dndt, example_jacobian = get_rates_and_jacobian(nstart, params_exjac, 0.0) # TODO: Fill in global variables 
+    dndt, example_jacobian = get_rates_and_jacobian(nstart, params_exjac, 0.0; globvars...)
     t_after_jac = time()
 
     write_to_log(logfile, "$(Dates.format(now(), "(HH:MM:SS)")) Finished first chemical jacobian compile")
@@ -1618,18 +1795,19 @@ println("Time to beginning convergence is $(format_sec_or_min(time()-t1))\n\n")
 #                                                                              #
 # **************************************************************************** #
 
-# First ste up a dictionary to store the parameter DataFrames, so that we can 
+# First set up a dictionary to store the parameter DataFrames, so that we can 
 # make more than one call to writing out the file (the normal call and also the
 # call in the case of the model crashing)
 
-param_df_dict = OrderedDict("General"=>PARAMETERS_GEN, 
-                            "AtmosphericConditions"=>PARAMETERS_CONDITIONS, 
-                            "AltGrid"=>PARAMETERS_ALTGRID, 
+param_df_dict = OrderedDict("General"=>PARAMETERS_GEN,
+                            "AtmosphericConditions"=>PARAMETERS_CONDITIONS,
+                            "AltGrid"=>PARAMETERS_ALTGRID,
                             "AltInfo"=>PARAMETERS_ALT_INFO,
                             "SpeciesLists"=>PARAMETERS_SPLISTS,
                             "TemperatureArrays"=>PARAMETERS_TEMPERATURE_ARRAYS,
-                            "Crosssections"=>PARAMETERS_XSECTS, 
+                            "Crosssections"=>PARAMETERS_XSECTS,
                             "BoundaryConditions"=>PARAMETERS_BCS,
+                            "BoundaryConditionsHoriz"=>PARAMETERS_BCS_HORIZ,
                             "Solver" => PARAMETERS_SOLVER
                             )
 xlsx_parameter_log = "$(results_dir)$(sim_folder_name)/PARAMETERS.xlsx"
@@ -1637,7 +1815,7 @@ xlsx_parameter_log = "$(results_dir)$(sim_folder_name)/PARAMETERS.xlsx"
 ti = time()
 println("$(Dates.format(now(), "(HH:MM:SS)")) Beginning convergence")
 
-Dcoef_arr_template = zeros(size(Tn_arr)) # initialize diffusion coefficient array
+Dcoef_arr_template = [zeros(size(Tn_arr)) for ihoriz in 1:n_horiz] # initialize diffusion coefficient array
 
 atm_soln = Dict()
 
@@ -1645,23 +1823,25 @@ try
     global atm_soln, sim_time = evolve_atmosphere(n_current, mindt, maxdt; t_to_save=times_to_save, abstol=atol, reltol=rel_tol, 
                                  # glob vars from here.  
                                  absorber, active_species, active_longlived, active_shortlived, all_species, alt, 
-                                 collision_xsect, crosssection, Dcoef_arr_template, dt_incr_factor, dt_decr_factor, dz, 
+                                 collision_xsect, crosssection, Dcoef_arr_template, dt_incr_factor, dt_decr_factor, dz, dx,
                                  e_profile_type, error_checking_scheme, timestep_type, H2Oi, HDOi, 
                                  hot_H_network, hot_H_rc_funcs, hot_D_network, hot_D_rc_funcs, hot_H2_network, hot_H2_rc_funcs, hot_HD_network, hot_HD_rc_funcs,
                                  hrshortcode, Hs_dict,
                                  ion_species, inactive_species, Jratelist, logfile, M_P, molmass, monospace_choice, sansserif_choice,
                                  neutral_species, non_bdy_layers, num_layers, n_all_layers, n_alt_index, n_inactive, n_steps, 
                                  polarizability, planet, plot_grid, q, R_P, reaction_network, rshortcode, 
-                                 season_length_in_sec, sol_in_sec, solarflux, speciesbclist, speciescolor, speciesstyle, 
+                                 season_length_in_sec, sol_in_sec, solarflux, speciesbclist, speciesbclist_horiz, speciescolor, speciesstyle, horiz_wind_v,
+                                 enable_horiz_transport,
                                  Tn=Tn_arr, Ti=Ti_arr, Te=Te_arr, Tp=Tplasma_arr, Tprof_for_diffusion, transport_species, opt="",
                                  upper_lower_bdy_i, use_ambipolar, use_molec_diff, zmax)
 catch y
     XLSX.writetable(xlsx_parameter_log, param_df_dict...)
+
     write_to_log(logfile, "Terminated before completion at $(format_sec_or_min(time()-ti))", mode="a")
     throw("ERROR: Simulation terminated before completion with exception:")
 end
 
-tf = time() 
+tf = time()
 
 write_to_log(logfile, "Finished!\nSimulation active convergence runtime $(format_sec_or_min(tf-ti))", mode="a")
 
@@ -1677,11 +1857,11 @@ println("$(Dates.format(now(), "(HH:MM:SS)")) Simulation active convergence runt
 if problem_type == "SS"
     # Update short-lived species one more time
     println("One last update of short-lived species")
-    n_short = flatten_atm(external_storage, active_shortlived; num_layers)
+    n_short = flatten_atm(external_storage, active_shortlived, n_horiz; num_layers)
     Jrates = deepcopy(Float64[external_storage[jr][ialt] for jr in Jratelist, ialt in 1:num_layers])
     set_concentrations!(external_storage, atm_soln.u, n_short, inactive, 
                         active_longlived, active_shortlived, inactive_species, Jrates, Tn_arr, Ti_arr, Te_arr)
-    nc_all = merge(external_storage, unflatten_atm(atm_soln.u, active_longlived; num_layers))
+    nc_all = merge(external_storage, unflatten_atm(atm_soln.u, active_longlived, n_horiz; num_layers))
 
     println("Plotting final atmosphere, writing out state")
     # Make final atmosphere plot
@@ -1692,12 +1872,19 @@ if problem_type == "SS"
     write_final_state(nc_all, results_dir, sim_folder_name, final_atm_file; alt, num_layers, hrshortcode, Jratedict=Jrates, rshortcode, external_storage)
     write_to_log(logfile, "$(Dates.format(now(), "(HH:MM:SS)")) Making production/loss plots", mode="a")
     println("Making production/loss plots (this tends to take several minutes)")
-    plot_production_and_loss(nc_all, results_dir, sim_folder_name; nonthermal=nontherm, all_species, alt, chem_species, collision_xsect, 
-                              dz, hot_D_rc_funcs, hot_H_rc_funcs, hot_H2_rc_funcs, hot_HD_rc_funcs, Hs_dict, 
-                              hot_H_network, hot_D_network, hot_H2_network, hot_HD_network, hrshortcode, ion_species, Jratedict,
-                              molmass, neutral_species, non_bdy_layers, num_layers, n_all_layers, n_alt_index, polarizability, 
-                              plot_grid, q, rshortcode, reaction_network, speciesbclist, Tn=Tn_arr, Ti=Ti_arr, Te=Te_arr, Tp=Tplasma_arr, 
-                              Tprof_for_Hs, Tprof_for_diffusion, transport_species, upper_lower_bdy_i, upper_lower_bdy, zmax)
+    if make_P_and_L_plots
+        plot_production_and_loss(nc_all, results_dir, sim_folder_name, n_horiz;
+                                 separate_cols=true, nonthermal=nontherm, all_species, alt, chem_species,
+                                 collision_xsect, dz, dx, hot_D_rc_funcs, hot_H_rc_funcs,
+                                 hot_H2_rc_funcs, hot_HD_rc_funcs, Hs_dict, hot_H_network,
+                                 hot_D_network, hot_H2_network, hot_HD_network, hrshortcode,
+                                 ion_species, Jratedict, molmass, neutral_species,
+                                 non_bdy_layers, num_layers, n_all_layers, n_alt_index,
+                                 polarizability, plot_grid, q, rshortcode, reaction_network,
+                                 speciesbclist, speciesbclist_horiz, Tn=Tn_arr, Ti=Ti_arr,
+                                 Te=Te_arr, Tp=Tplasma_arr, Tprof_for_Hs, Tprof_for_diffusion,
+                                 transport_species, upper_lower_bdy_i, upper_lower_bdy, zmax)
+    end
 elseif problem_type == "ODE"
 
     L = length(atm_soln.u)
@@ -1710,16 +1897,16 @@ elseif problem_type == "ODE"
             # Currently there's no workaround for this and you just have to remember NOT TO TRUST Jrates
             # at any timestep except the very last. 
             # TODO: Fix this so we just don't write Jrates in these iterations...
-            local nc_all = merge(external_storage, unflatten_atm(atm_state, active_longlived; num_layers))
+            local nc_all = merge(external_storage, unflatten_atm(atm_state, active_longlived, n_horiz; num_layers))
             write_atmosphere(nc_all, results_dir*sim_folder_name*"/atm_state_t_$(timestep).h5"; alt, num_layers, hrshortcode, rshortcode) 
         elseif i == L
             # Update short-lived species one more time
             println("One last update of short-lived species")
-            local n_short = flatten_atm(external_storage, active_shortlived; num_layers)
+            local n_short = flatten_atm(external_storage, active_shortlived, n_horiz; num_layers)
             local Jrates = deepcopy(Float64[external_storage[jr][ialt] for jr in Jratelist, ialt in 1:num_layers])
             set_concentrations!(external_storage, atm_state, n_short, inactive, Jrates; active_longlived, active_shortlived, 
                                inactive_species, Tn=Tn_arr, Ti=Ti_arr, Te=Te_arr, num_layers)
-            local nc_all = merge(external_storage, unflatten_atm(atm_state, active_longlived; num_layers))
+            local nc_all = merge(external_storage, unflatten_atm(atm_state, active_longlived, n_horiz; num_layers))
 
             # Make final atmosphere plot
             println("Plotting final atmosphere, writing out state")
@@ -1729,12 +1916,19 @@ elseif problem_type == "ODE"
             write_final_state(nc_all, results_dir, sim_folder_name, final_atm_file; alt, num_layers, hrshortcode, Jratedict=Jrates, rshortcode, external_storage)
             write_to_log(logfile, "$(Dates.format(now(), "(HH:MM:SS)")) Making production/loss plots", mode="a")
             println("Making production/loss plots (this tends to take several minutes)")
-            plot_production_and_loss(nc_all, results_dir, sim_folder_name; nonthermal=nontherm, all_species, alt, chem_species, collision_xsect, 
-                                      dz, hot_D_rc_funcs, hot_H_rc_funcs, hot_H2_rc_funcs, hot_HD_rc_funcs, Hs_dict, 
-                                      hot_H_network, hot_D_network, hot_H2_network, hot_HD_network, hrshortcode, ion_species, Jratedict,
-                                      molmass, neutral_species, non_bdy_layers, num_layers, n_all_layers, n_alt_index, polarizability, 
-                                      plot_grid, q, rshortcode, reaction_network, speciesbclist, Tn=Tn_arr, Ti=Ti_arr, Te=Te_arr, Tp=Tplasma_arr, 
-                                      Tprof_for_Hs, Tprof_for_diffusion, transport_species, upper_lower_bdy_i, upper_lower_bdy, zmax)
+            if make_P_and_L_plots
+                plot_production_and_loss(nc_all, results_dir, sim_folder_name, n_horiz;
+                                         separate_cols=true, nonthermal=nontherm, all_species, alt, chem_species,
+                                         collision_xsect, dz, dx, hot_D_rc_funcs, hot_H_rc_funcs,
+                                         hot_H2_rc_funcs, hot_HD_rc_funcs, Hs_dict, hot_H_network,
+                                         hot_D_network, hot_H2_network, hot_HD_network, hrshortcode,
+                                         ion_species, Jratedict, molmass, neutral_species,
+                                         non_bdy_layers, num_layers, n_all_layers, n_alt_index,
+                                         polarizability, plot_grid, q, rshortcode, reaction_network,
+                                         speciesbclist, speciesbclist_horiz, Tn=Tn_arr, Ti=Ti_arr,
+                                         Te=Te_arr, Tp=Tplasma_arr, Tprof_for_Hs, Tprof_for_diffusion,
+                                         transport_species, upper_lower_bdy_i, upper_lower_bdy, zmax)
+            end
 
         end
         global i += 1 
@@ -1742,31 +1936,41 @@ elseif problem_type == "ODE"
 elseif problem_type == "Gear"
     # Plot the final atmospheric state
     println("Plotting final atmosphere, writing out state")
-    final_E_profile = electron_density(atm_soln; e_profile_type, non_bdy_layers, ion_species)   
-    plot_atm(atm_soln, results_dir*sim_folder_name*"/final_atmosphere.png", abs_tol_for_plot, final_E_profile; ylims=[zmin/1e5, zmax/1e5],
+    final_E_profile = electron_density(atm_soln; e_profile_type, non_bdy_layers, ion_species, n_horiz)
+    plot_atm(atm_soln, results_dir*sim_folder_name*"/final_atmosphere.png", abs_tol_for_plot, final_E_profile, n_horiz; ylims=[zmin/1e5, zmax/1e5],
              t="final converged state, total time = $(sim_time)", neutral_species, ion_species, plot_grid, speciescolor, speciesstyle, zmax, hrshortcode, rshortcode,
              monospace_choice, sansserif_choice)
 
     # Collect the J rates
-    Jratedict = Dict{Symbol, Vector{Float64}}([j=>external_storage[j] for j in keys(external_storage) if occursin("J", string(j))])
+    Jratedict = Dict{Symbol, Vector{Array{Float64}}}([j=>external_storage[j] for j in keys(external_storage) if occursin("J", string(j))])
 
     # Write out the final state to a unique file for easy finding
-    write_final_state(atm_soln, results_dir, sim_folder_name, final_atm_file; alt, num_layers, hrshortcode, Jratedict, rshortcode, external_storage)
+    write_final_state(atm_soln, results_dir, sim_folder_name, final_atm_file, n_horiz; alt, num_layers, hrshortcode, Jratedict, rshortcode, external_storage)
+
+    @assert size(Tn_arr) == (n_horiz, num_layers+2) "Tn_arr should be (n_horiz, num_layers+2), got $(size(Tn_arr))"
+    @assert size(Ti_arr) == (n_horiz, num_layers+2) "Ti_arr must be (n_horiz, num_layers+2)"
+    @assert size(Te_arr) == (n_horiz, num_layers+2) "Te_arr must be (n_horiz, num_layers+2)"
 
     # Write out the final column rates to the reaction log
-    calculate_and_write_column_rates(used_rxns_spreadsheet_name, atm_soln; all_species, dz, ion_species, num_layers, reaction_network, results_dir, sim_folder_name, 
-                                                              Tn=Tn_arr[2:end-1], Ti=Ti_arr[2:end-1], Te=Te_arr[2:end-1])
+    calculate_and_write_column_rates(used_rxns_spreadsheet_name, atm_soln, n_horiz; all_species, dz, ion_species, num_layers, reaction_network, results_dir, sim_folder_name, 
+                                                              Tn=Tn_arr, Ti=Ti_arr, Te=Te_arr)
     
     write_to_log(logfile, "$(Dates.format(now(), "(HH:MM:SS)")) Making production/loss plots", mode="a")
     println("$(Dates.format(now(), "(HH:MM:SS)")) Making production/loss plots (this tends to take several minutes)")
     # make production and loss plots
     if make_P_and_L_plots
-        plot_production_and_loss(atm_soln, results_dir, sim_folder_name; nonthermal=nontherm, all_species, alt, chem_species, collision_xsect, 
-                                  dz, hot_D_rc_funcs, hot_H_rc_funcs, hot_H2_rc_funcs, hot_HD_rc_funcs, Hs_dict, 
-                                  hot_H_network, hot_D_network, hot_H2_network, hot_HD_network, hrshortcode, ion_species, Jratedict, M_P, 
-                                  molmass, monospace_choice, neutral_species, non_bdy_layers, num_layers, n_all_layers, n_alt_index, polarizability, planet,
-                                  plot_grid, q, R_P, rshortcode, reaction_network, sansserif_choice, speciesbclist, Tn=Tn_arr, Ti=Ti_arr, Te=Te_arr, Tp=Tplasma_arr, 
-                                  Tprof_for_Hs, Tprof_for_diffusion, transport_species, upper_lower_bdy_i, upper_lower_bdy, use_ambipolar, use_molec_diff, zmax)
+        plot_production_and_loss(atm_soln, results_dir, sim_folder_name, n_horiz;
+                                 separate_cols=true, nonthermal=nontherm, all_species, alt, chem_species,
+                                 collision_xsect, dz, dx, hot_D_rc_funcs, hot_H_rc_funcs,
+                                 hot_H2_rc_funcs, hot_HD_rc_funcs, Hs_dict, hot_H_network,
+                                 hot_D_network, hot_H2_network, hot_HD_network, hrshortcode,
+                                 ion_species, Jratedict, M_P, molmass, monospace_choice,
+                                 neutral_species, non_bdy_layers, num_layers, n_all_layers, n_alt_index,
+                                 polarizability, planet, plot_grid, q, R_P, rshortcode, reaction_network,
+                                 sansserif_choice, speciesbclist, speciesbclist_horiz,
+                                 Tn=Tn_arr, Ti=Ti_arr, Te=Te_arr, Tp=Tplasma_arr,
+                                 Tprof_for_Hs, Tprof_for_diffusion, transport_species,
+                                 upper_lower_bdy_i, upper_lower_bdy, use_ambipolar, use_molec_diff, zmax)
     end
 
 else
